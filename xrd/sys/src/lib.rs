// Generated by gir (https://github.com/gtk-rs/gir @ 2358cc24efd2)
// from ../../gir-files (@ eab91ba8f88b)
// from ../../xrd-gir-files (@ 3896faadf111)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(
    clippy::approx_constant,
    clippy::type_complexity,
    clippy::unreadable_literal,
    clippy::upper_case_acronyms
)]
#![cfg_attr(feature = "dox", feature(doc_cfg))]

#[allow(unused_imports)]
use libc::{
    c_char, c_double, c_float, c_int, c_long, c_short, c_uchar, c_uint, c_ulong, c_ushort, c_void,
    intptr_t, size_t, ssize_t, uintptr_t, FILE,
};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Enums
pub type XrdClientMode = c_int;
pub const XRD_CLIENT_MODE_OVERLAY: XrdClientMode = 0;
pub const XRD_CLIENT_MODE_SCENE: XrdClientMode = 1;

pub type XrdContainerAttachment = c_int;
pub const XRD_CONTAINER_ATTACHMENT_NONE: XrdContainerAttachment = 0;
pub const XRD_CONTAINER_ATTACHMENT_HEAD: XrdContainerAttachment = 1;
pub const XRD_CONTAINER_ATTACHMENT_HAND: XrdContainerAttachment = 2;

pub type XrdContainerLayout = c_int;
pub const XRD_CONTAINER_NO_LAYOUT: XrdContainerLayout = 0;
pub const XRD_CONTAINER_HORIZONTAL: XrdContainerLayout = 1;
pub const XRD_CONTAINER_VERTICAL: XrdContainerLayout = 2;
pub const XRD_CONTAINER_RELATIVE: XrdContainerLayout = 3;

pub type XrdHoverMode = c_int;
pub const XRD_HOVER_MODE_EVERYTHING: XrdHoverMode = 0;
pub const XRD_HOVER_MODE_BUTTONS: XrdHoverMode = 1;

pub type XrdInputSynthButton = c_int;
pub const LEFT_BUTTON: XrdInputSynthButton = 1;
pub const MIDDLE_BUTTON: XrdInputSynthButton = 2;
pub const RIGHT_BUTTON: XrdInputSynthButton = 3;
pub const SCROLL_UP: XrdInputSynthButton = 4;
pub const SCROLL_DOWN: XrdInputSynthButton = 5;
pub const SCROLL_LEFT: XrdInputSynthButton = 6;
pub const SCROLL_RIGHT: XrdInputSynthButton = 7;

// Constants
pub const XRD_TIP_APPARENT_SIZE_DISTANCE: c_double = 3.000000;
pub const XRD_TIP_VIEWPORT_SCALE: c_int = 3;

// Flags
pub type XrdWindowFlags = c_uint;
pub const XRD_WINDOW_HOVERABLE: XrdWindowFlags = 1;
pub const XRD_WINDOW_DRAGGABLE: XrdWindowFlags = 2;
pub const XRD_WINDOW_MANAGED: XrdWindowFlags = 4;
pub const XRD_WINDOW_DESTROY_WITH_PARENT: XrdWindowFlags = 8;
pub const XRD_WINDOW_BUTTON: XrdWindowFlags = 16;

// Records
#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdClickEvent {
    pub window: *mut XrdWindow,
    pub position: *mut graphene::graphene_point_t,
    pub button: XrdInputSynthButton,
    pub state: gboolean,
    pub controller: *mut gxr::GxrController,
}

impl ::std::fmt::Debug for XrdClickEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdClickEvent @ {self:p}"))
            .field("window", &self.window)
            .field("position", &self.position)
            .field("button", &self.button)
            .field("state", &self.state)
            .field("controller", &self.controller)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdClientClass {
    pub parent: gobject::GObjectClass,
    pub add_button: Option<
        unsafe extern "C" fn(
            *mut XrdClient,
            *mut *mut XrdWindow,
            c_int,
            *mut *mut c_char,
            *mut graphene::graphene_point3d_t,
            gobject::GCallback,
            gpointer,
        ) -> gboolean,
    >,
    pub get_gulkan: Option<unsafe extern "C" fn(*mut XrdClient) -> *mut gulkan::GulkanClient>,
    pub init_controller: Option<unsafe extern "C" fn(*mut XrdClient, *mut gxr::GxrController)>,
    pub window_new_from_meters: Option<
        unsafe extern "C" fn(
            *mut XrdClient,
            *const c_char,
            c_float,
            c_float,
            c_float,
        ) -> *mut XrdWindow,
    >,
    pub window_new_from_data:
        Option<unsafe extern "C" fn(*mut XrdClient, *mut XrdWindowData) -> *mut XrdWindow>,
    pub window_new_from_pixels: Option<
        unsafe extern "C" fn(*mut XrdClient, *const c_char, u32, u32, c_float) -> *mut XrdWindow,
    >,
    pub window_new_from_native: Option<
        unsafe extern "C" fn(
            *mut XrdClient,
            *const c_char,
            gpointer,
            u32,
            u32,
            c_float,
        ) -> *mut XrdWindow,
    >,
}

impl ::std::fmt::Debug for XrdClientClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdClientClass @ {self:p}"))
            .field("parent", &self.parent)
            .field("add_button", &self.add_button)
            .field("get_gulkan", &self.get_gulkan)
            .field("init_controller", &self.init_controller)
            .field("window_new_from_meters", &self.window_new_from_meters)
            .field("window_new_from_data", &self.window_new_from_data)
            .field("window_new_from_pixels", &self.window_new_from_pixels)
            .field("window_new_from_native", &self.window_new_from_native)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdContainerClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for XrdContainerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdContainerClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdDesktopCursorData {
    pub cursor: *mut XrdDesktopCursor,
    pub context: *mut gxr::GxrContext,
    pub keep_apparent_size: gboolean,
    pub width_meters: c_float,
    pub cached_width_meters: c_float,
    pub hotspot_x: c_int,
    pub hotspot_y: c_int,
    pub texture_width: u32,
    pub texture_height: u32,
}

impl ::std::fmt::Debug for XrdDesktopCursorData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdDesktopCursorData @ {self:p}"))
            .field("cursor", &self.cursor)
            .field("context", &self.context)
            .field("keep_apparent_size", &self.keep_apparent_size)
            .field("width_meters", &self.width_meters)
            .field("cached_width_meters", &self.cached_width_meters)
            .field("hotspot_x", &self.hotspot_x)
            .field("hotspot_y", &self.hotspot_y)
            .field("texture_width", &self.texture_width)
            .field("texture_height", &self.texture_height)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdDesktopCursorInterface {
    pub parent: gobject::GTypeInterface,
    pub submit_texture: Option<unsafe extern "C" fn(*mut XrdDesktopCursor)>,
    pub set_and_submit_texture:
        Option<unsafe extern "C" fn(*mut XrdDesktopCursor, *mut gulkan::GulkanTexture)>,
    pub get_texture:
        Option<unsafe extern "C" fn(*mut XrdDesktopCursor) -> *mut gulkan::GulkanTexture>,
    pub show: Option<unsafe extern "C" fn(*mut XrdDesktopCursor)>,
    pub hide: Option<unsafe extern "C" fn(*mut XrdDesktopCursor)>,
    pub set_width_meters: Option<unsafe extern "C" fn(*mut XrdDesktopCursor, c_float)>,
    pub get_data: Option<unsafe extern "C" fn(*mut XrdDesktopCursor) -> *mut XrdDesktopCursorData>,
    pub get_transformation:
        Option<unsafe extern "C" fn(*mut XrdDesktopCursor, *mut graphene::graphene_matrix_t)>,
    pub set_transformation:
        Option<unsafe extern "C" fn(*mut XrdDesktopCursor, *mut graphene::graphene_matrix_t)>,
}

impl ::std::fmt::Debug for XrdDesktopCursorInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdDesktopCursorInterface @ {self:p}"))
            .field("parent", &self.parent)
            .field("submit_texture", &self.submit_texture)
            .field("set_and_submit_texture", &self.set_and_submit_texture)
            .field("get_texture", &self.get_texture)
            .field("show", &self.show)
            .field("hide", &self.hide)
            .field("set_width_meters", &self.set_width_meters)
            .field("get_data", &self.get_data)
            .field("get_transformation", &self.get_transformation)
            .field("set_transformation", &self.set_transformation)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdGrabEvent {
    pub pose: graphene::graphene_matrix_t,
    pub controller: *mut gxr::GxrController,
}

impl ::std::fmt::Debug for XrdGrabEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdGrabEvent @ {self:p}"))
            .field("pose", &self.pose)
            .field("controller", &self.controller)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdHoverEvent {
    pub point: graphene::graphene_point3d_t,
    pub pose: graphene::graphene_matrix_t,
    pub distance: c_float,
    pub controller: *mut gxr::GxrController,
}

impl ::std::fmt::Debug for XrdHoverEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdHoverEvent @ {self:p}"))
            .field("point", &self.point)
            .field("pose", &self.pose)
            .field("distance", &self.distance)
            .field("controller", &self.controller)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdInputSynthClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for XrdInputSynthClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdInputSynthClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdMoveCursorEvent {
    pub window: *mut XrdWindow,
    pub position: *mut graphene::graphene_point_t,
    pub ignore: gboolean,
}

impl ::std::fmt::Debug for XrdMoveCursorEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdMoveCursorEvent @ {self:p}"))
            .field("window", &self.window)
            .field("position", &self.position)
            .field("ignore", &self.ignore)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdNoHoverEvent {
    pub controller: *mut gxr::GxrController,
}

impl ::std::fmt::Debug for XrdNoHoverEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdNoHoverEvent @ {self:p}"))
            .field("controller", &self.controller)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdShakeCompensatorClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for XrdShakeCompensatorClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdShakeCompensatorClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdTransformTransition {
    pub window: *mut XrdWindow,
    pub from: graphene::graphene_matrix_t,
    pub to: graphene::graphene_matrix_t,
    pub from_scaling: c_float,
    pub to_scaling: c_float,
    pub interpolate: c_float,
    pub last_timestamp: i64,
}

impl ::std::fmt::Debug for XrdTransformTransition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdTransformTransition @ {self:p}"))
            .field("window", &self.window)
            .field("from", &self.from)
            .field("to", &self.to)
            .field("from_scaling", &self.from_scaling)
            .field("to_scaling", &self.to_scaling)
            .field("interpolate", &self.interpolate)
            .field("last_timestamp", &self.last_timestamp)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdWindowData {
    pub native: gpointer,
    pub texture_width: u32,
    pub texture_height: u32,
    pub title: *mut glib::GString,
    pub initial_size_meters: graphene::graphene_point_t,
    pub scale: c_float,
    pub transform: graphene::graphene_matrix_t,
    pub child_window: *mut XrdWindowData,
    pub parent_window: *mut XrdWindowData,
    pub child_offset_center: graphene::graphene_point_t,
    pub reset_transform: graphene::graphene_matrix_t,
    pub pinned: gboolean,
    pub texture: *mut gulkan::GulkanTexture,
    pub xrd_window: *mut XrdWindow,
    pub owned_by_window: gboolean,
}

impl ::std::fmt::Debug for XrdWindowData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdWindowData @ {self:p}"))
            .field("native", &self.native)
            .field("texture_width", &self.texture_width)
            .field("texture_height", &self.texture_height)
            .field("title", &self.title)
            .field("initial_size_meters", &self.initial_size_meters)
            .field("scale", &self.scale)
            .field("transform", &self.transform)
            .field("child_window", &self.child_window)
            .field("parent_window", &self.parent_window)
            .field("child_offset_center", &self.child_offset_center)
            .field("reset_transform", &self.reset_transform)
            .field("pinned", &self.pinned)
            .field("texture", &self.texture)
            .field("xrd_window", &self.xrd_window)
            .field("owned_by_window", &self.owned_by_window)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdWindowInterface {
    pub parent: gobject::GTypeInterface,
    pub set_transformation:
        Option<unsafe extern "C" fn(*mut XrdWindow, *mut graphene::graphene_matrix_t) -> gboolean>,
    pub get_transformation:
        Option<unsafe extern "C" fn(*mut XrdWindow, *mut graphene::graphene_matrix_t) -> gboolean>,
    pub get_transformation_no_scale:
        Option<unsafe extern "C" fn(*mut XrdWindow, *mut graphene::graphene_matrix_t) -> gboolean>,
    pub submit_texture: Option<unsafe extern "C" fn(*mut XrdWindow)>,
    pub set_and_submit_texture:
        Option<unsafe extern "C" fn(*mut XrdWindow, *mut gulkan::GulkanTexture)>,
    pub get_texture: Option<unsafe extern "C" fn(*mut XrdWindow) -> *mut gulkan::GulkanTexture>,
    pub poll_event: Option<unsafe extern "C" fn(*mut XrdWindow)>,
    pub emit_grab_start: Option<unsafe extern "C" fn(*mut XrdWindow, *mut gxr::GxrController)>,
    pub emit_grab: Option<unsafe extern "C" fn(*mut XrdWindow, *mut XrdGrabEvent)>,
    pub emit_release: Option<unsafe extern "C" fn(*mut XrdWindow, *mut gxr::GxrController)>,
    pub emit_hover_end: Option<unsafe extern "C" fn(*mut XrdWindow, *mut gxr::GxrController)>,
    pub emit_hover: Option<unsafe extern "C" fn(*mut XrdWindow, *mut XrdHoverEvent)>,
    pub emit_hover_start: Option<unsafe extern "C" fn(*mut XrdWindow, *mut gxr::GxrController)>,
    pub add_child: Option<
        unsafe extern "C" fn(*mut XrdWindow, *mut XrdWindow, *mut graphene::graphene_point_t),
    >,
    pub set_color: Option<unsafe extern "C" fn(*mut XrdWindow, *const graphene::graphene_vec3_t)>,
    pub set_flip_y: Option<unsafe extern "C" fn(*mut XrdWindow, gboolean)>,
    pub show: Option<unsafe extern "C" fn(*mut XrdWindow)>,
    pub hide: Option<unsafe extern "C" fn(*mut XrdWindow)>,
    pub is_visible: Option<unsafe extern "C" fn(*mut XrdWindow) -> gboolean>,
    pub constructed: Option<unsafe extern "C" fn(*mut gobject::GObject)>,
    pub get_data: Option<unsafe extern "C" fn(*mut XrdWindow) -> *mut XrdWindowData>,
    pub windows_created: c_uint,
}

impl ::std::fmt::Debug for XrdWindowInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdWindowInterface @ {self:p}"))
            .field("parent", &self.parent)
            .field("set_transformation", &self.set_transformation)
            .field("get_transformation", &self.get_transformation)
            .field(
                "get_transformation_no_scale",
                &self.get_transformation_no_scale,
            )
            .field("submit_texture", &self.submit_texture)
            .field("set_and_submit_texture", &self.set_and_submit_texture)
            .field("get_texture", &self.get_texture)
            .field("poll_event", &self.poll_event)
            .field("emit_grab_start", &self.emit_grab_start)
            .field("emit_grab", &self.emit_grab)
            .field("emit_release", &self.emit_release)
            .field("emit_hover_end", &self.emit_hover_end)
            .field("emit_hover", &self.emit_hover)
            .field("emit_hover_start", &self.emit_hover_start)
            .field("add_child", &self.add_child)
            .field("set_color", &self.set_color)
            .field("set_flip_y", &self.set_flip_y)
            .field("show", &self.show)
            .field("hide", &self.hide)
            .field("is_visible", &self.is_visible)
            .field("constructed", &self.constructed)
            .field("get_data", &self.get_data)
            .field("windows_created", &self.windows_created)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdWindowManagerClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for XrdWindowManagerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdWindowManagerClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

// Classes
#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdClient {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for XrdClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdClient @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
pub struct XrdContainer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for XrdContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdContainer @ {self:p}")).finish()
    }
}

#[repr(C)]
pub struct XrdInputSynth {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for XrdInputSynth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdInputSynth @ {self:p}"))
            .finish()
    }
}

#[repr(C)]
pub struct XrdShakeCompensator {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for XrdShakeCompensator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdShakeCompensator @ {self:p}"))
            .finish()
    }
}

#[repr(C)]
pub struct XrdWindowManager {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for XrdWindowManager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdWindowManager @ {self:p}"))
            .finish()
    }
}

// Interfaces
#[repr(C)]
pub struct XrdDesktopCursor {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for XrdDesktopCursor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "XrdDesktopCursor @ {self:p}")
    }
}

#[repr(C)]
pub struct XrdWindow {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for XrdWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "XrdWindow @ {self:p}")
    }
}

#[link(name = "xrdesktop-0.15", modifiers = "-bundle,+whole-archive", kind = "static")]
extern "C" {

    //=========================================================================
    // XrdClient
    //=========================================================================
    pub fn xrd_client_get_type() -> GType;
    pub fn xrd_client_new() -> *mut XrdClient;
    pub fn xrd_client_new_with_mode(mode: XrdClientMode) -> *mut XrdClient;
    pub fn xrd_client_add_button(
        self_: *mut XrdClient,
        button: *mut XrdWindow,
        position: *mut graphene::graphene_point3d_t,
        press_callback: gobject::GCallback,
        press_callback_data: gpointer,
    );
    pub fn xrd_client_add_container(self_: *mut XrdClient, container: *mut XrdContainer);
    pub fn xrd_client_add_window(
        self_: *mut XrdClient,
        window: *mut XrdWindow,
        draggable: gboolean,
        lookup_key: gpointer,
    );
    pub fn xrd_client_button_new_from_icon(
        self_: *mut XrdClient,
        width: c_float,
        height: c_float,
        ppm: c_float,
        url: *const c_char,
    ) -> *mut XrdWindow;
    pub fn xrd_client_button_new_from_text(
        self_: *mut XrdClient,
        width: c_float,
        height: c_float,
        ppm: c_float,
        label_count: c_int,
        label: *mut *mut c_char,
    ) -> *mut XrdWindow;
    pub fn xrd_client_get_controllers(self_: *mut XrdClient) -> *mut glib::GSList;
    pub fn xrd_client_get_desktop_cursor(self_: *mut XrdClient) -> *mut XrdDesktopCursor;
    pub fn xrd_client_get_gulkan(self_: *mut XrdClient) -> *mut gulkan::GulkanClient;
    pub fn xrd_client_get_gxr_context(self_: *mut XrdClient) -> *mut gxr::GxrContext;
    pub fn xrd_client_get_input_synth(self_: *mut XrdClient) -> *mut XrdInputSynth;
    pub fn xrd_client_get_keyboard_window(self_: *mut XrdClient) -> *mut XrdWindow;
    pub fn xrd_client_get_manager(self_: *mut XrdClient) -> *mut XrdWindowManager;
    pub fn xrd_client_get_synth_hovered(self_: *mut XrdClient) -> *mut XrdWindow;
    pub fn xrd_client_get_upload_layout(self_: *mut XrdClient) -> u32;
    pub fn xrd_client_get_windows(self_: *mut XrdClient) -> *mut glib::GSList;
    pub fn xrd_client_lookup_window(self_: *mut XrdClient, key: gpointer) -> *mut XrdWindow;
    pub fn xrd_client_poll_input_events(self_: *mut XrdClient) -> gboolean;
    pub fn xrd_client_poll_runtime_events(self_: *mut XrdClient) -> gboolean;
    pub fn xrd_client_remove_container(self_: *mut XrdClient, container: *mut XrdContainer);
    pub fn xrd_client_remove_window(self_: *mut XrdClient, window: *mut XrdWindow);
    pub fn xrd_client_set_pin(self_: *mut XrdClient, win: *mut XrdWindow, pin: gboolean);
    pub fn xrd_client_show_pinned_only(self_: *mut XrdClient, pinned_only: gboolean);
    pub fn xrd_client_switch_mode(self_: *mut XrdClient) -> *mut XrdClient;

    //=========================================================================
    // XrdContainer
    //=========================================================================
    pub fn xrd_container_get_type() -> GType;
    pub fn xrd_container_new() -> *mut XrdContainer;
    pub fn xrd_container_add_window(
        self_: *mut XrdContainer,
        window: *mut XrdWindow,
        relative_transform: *mut graphene::graphene_matrix_t,
    );
    pub fn xrd_container_center_view(
        self_: *mut XrdContainer,
        context: *mut gxr::GxrContext,
        distance: c_float,
    );
    pub fn xrd_container_get_distance(self_: *mut XrdContainer) -> c_float;
    pub fn xrd_container_get_windows(self_: *mut XrdContainer) -> *mut glib::GSList;
    pub fn xrd_container_hide(self_: *mut XrdContainer);
    pub fn xrd_container_is_visible(self_: *mut XrdContainer) -> gboolean;
    pub fn xrd_container_remove_window(self_: *mut XrdContainer, window: *mut XrdWindow);
    pub fn xrd_container_set_attachment(
        self_: *mut XrdContainer,
        attachment: XrdContainerAttachment,
        controller: *mut gxr::GxrController,
    );
    pub fn xrd_container_set_distance(self_: *mut XrdContainer, distance: c_float);
    pub fn xrd_container_set_layout(self_: *mut XrdContainer, layout: XrdContainerLayout);
    pub fn xrd_container_show(self_: *mut XrdContainer);
    pub fn xrd_container_step(self_: *mut XrdContainer, context: *mut gxr::GxrContext) -> gboolean;

    //=========================================================================
    // XrdInputSynth
    //=========================================================================
    pub fn xrd_input_synth_get_type() -> GType;
    pub fn xrd_input_synth_new() -> *mut XrdInputSynth;
    pub fn xrd_input_synth_create_action_set(
        self_: *mut XrdInputSynth,
        context: *mut gxr::GxrContext,
    ) -> *mut gxr::GxrActionSet;
    pub fn xrd_input_synth_get_primary_controller(
        self_: *mut XrdInputSynth,
    ) -> *mut gxr::GxrController;
    pub fn xrd_input_synth_make_primary(
        self_: *mut XrdInputSynth,
        controller: *mut gxr::GxrController,
    );
    pub fn xrd_input_synth_move_cursor(
        self_: *mut XrdInputSynth,
        window: *mut XrdWindow,
        controller_pose: *mut graphene::graphene_matrix_t,
        intersection: *mut graphene::graphene_point3d_t,
    );
    pub fn xrd_input_synth_reset_press_state(self_: *mut XrdInputSynth);
    pub fn xrd_input_synth_reset_scroll(self_: *mut XrdInputSynth);

    //=========================================================================
    // XrdShakeCompensator
    //=========================================================================
    pub fn xrd_shake_compensator_get_type() -> GType;
    pub fn xrd_shake_compensator_new() -> *mut XrdShakeCompensator;
    pub fn xrd_shake_compensator_get_button(self_: *mut XrdShakeCompensator)
        -> XrdInputSynthButton;
    pub fn xrd_shake_compensator_is_drag(
        self_: *mut XrdShakeCompensator,
        window: *mut XrdWindow,
        controller_pose: *mut graphene::graphene_matrix_t,
        intersection: *mut graphene::graphene_point3d_t,
    ) -> gboolean;
    pub fn xrd_shake_compensator_is_recording(self_: *mut XrdShakeCompensator) -> gboolean;
    pub fn xrd_shake_compensator_record(
        self_: *mut XrdShakeCompensator,
        position: *mut graphene::graphene_point_t,
    );
    pub fn xrd_shake_compensator_replay_move_queue(
        self_: *mut XrdShakeCompensator,
        synth: *mut XrdInputSynth,
        move_cursor_event_signal: c_uint,
        hover_window: *mut XrdWindow,
    );
    pub fn xrd_shake_compensator_reset(self_: *mut XrdShakeCompensator);
    pub fn xrd_shake_compensator_start_recording(
        self_: *mut XrdShakeCompensator,
        button: XrdInputSynthButton,
    );

    //=========================================================================
    // XrdWindowManager
    //=========================================================================
    pub fn xrd_window_manager_get_type() -> GType;
    pub fn xrd_window_manager_new() -> *mut XrdWindowManager;
    pub fn xrd_window_manager_add_container(
        self_: *mut XrdWindowManager,
        container: *mut XrdContainer,
    );
    pub fn xrd_window_manager_add_window(
        self_: *mut XrdWindowManager,
        window: *mut XrdWindow,
        flags: XrdWindowFlags,
    );
    pub fn xrd_window_manager_arrange_reset(self_: *mut XrdWindowManager);
    pub fn xrd_window_manager_arrange_sphere(
        self_: *mut XrdWindowManager,
        context: *mut gxr::GxrContext,
    ) -> gboolean;
    pub fn xrd_window_manager_check_grab(
        self_: *mut XrdWindowManager,
        controller: *mut gxr::GxrController,
    );
    pub fn xrd_window_manager_check_release(
        self_: *mut XrdWindowManager,
        controller: *mut gxr::GxrController,
    );
    pub fn xrd_window_manager_drag_start(
        self_: *mut XrdWindowManager,
        controller: *mut gxr::GxrController,
    );
    pub fn xrd_window_manager_get_buttons(self_: *mut XrdWindowManager) -> *mut glib::GSList;
    pub fn xrd_window_manager_get_hover_mode(self_: *mut XrdWindowManager) -> XrdHoverMode;
    pub fn xrd_window_manager_get_windows(self_: *mut XrdWindowManager) -> *mut glib::GSList;
    pub fn xrd_window_manager_poll_window_events(
        self_: *mut XrdWindowManager,
        context: *mut gxr::GxrContext,
    );
    pub fn xrd_window_manager_remove_container(
        self_: *mut XrdWindowManager,
        container: *mut XrdContainer,
    );
    pub fn xrd_window_manager_remove_window(self_: *mut XrdWindowManager, window: *mut XrdWindow);
    pub fn xrd_window_manager_scale(
        self_: *mut XrdWindowManager,
        grab_state: *mut gxr::GxrGrabState,
        factor: c_float,
        update_rate_ms: c_float,
    );
    pub fn xrd_window_manager_set_hover_mode(self_: *mut XrdWindowManager, mode: XrdHoverMode);
    pub fn xrd_window_manager_update_controller(
        self_: *mut XrdWindowManager,
        controller: *mut gxr::GxrController,
    );

    //=========================================================================
    // XrdDesktopCursor
    //=========================================================================
    pub fn xrd_desktop_cursor_get_type() -> GType;
    pub fn xrd_desktop_cursor_get_data(self_: *mut XrdDesktopCursor) -> *mut XrdDesktopCursorData;
    pub fn xrd_desktop_cursor_get_texture(
        self_: *mut XrdDesktopCursor,
    ) -> *mut gulkan::GulkanTexture;
    pub fn xrd_desktop_cursor_get_transformation(
        self_: *mut XrdDesktopCursor,
        matrix: *mut graphene::graphene_matrix_t,
    );
    pub fn xrd_desktop_cursor_hide(self_: *mut XrdDesktopCursor);
    pub fn xrd_desktop_cursor_init_settings(self_: *mut XrdDesktopCursor);
    pub fn xrd_desktop_cursor_set_and_submit_texture(
        self_: *mut XrdDesktopCursor,
        texture: *mut gulkan::GulkanTexture,
    );
    pub fn xrd_desktop_cursor_set_hotspot(
        self_: *mut XrdDesktopCursor,
        hotspot_x: c_int,
        hotspot_y: c_int,
    );
    pub fn xrd_desktop_cursor_set_transformation(
        self_: *mut XrdDesktopCursor,
        matrix: *mut graphene::graphene_matrix_t,
    );
    pub fn xrd_desktop_cursor_set_width_meters(self_: *mut XrdDesktopCursor, meters: c_float);
    pub fn xrd_desktop_cursor_show(self_: *mut XrdDesktopCursor);
    pub fn xrd_desktop_cursor_submit_texture(self_: *mut XrdDesktopCursor);
    pub fn xrd_desktop_cursor_update(
        self_: *mut XrdDesktopCursor,
        context: *mut gxr::GxrContext,
        window: *mut XrdWindow,
        intersection: *mut graphene::graphene_point3d_t,
    );

    //=========================================================================
    // XrdWindow
    //=========================================================================
    pub fn xrd_window_get_type() -> GType;
    pub fn xrd_window_new_from_data(
        self_: *mut XrdClient,
        data: *mut XrdWindowData,
    ) -> *mut XrdWindow;
    pub fn xrd_window_new_from_meters(
        client: *mut XrdClient,
        title: *const c_char,
        width: c_float,
        height: c_float,
        ppm: c_float,
    ) -> *mut XrdWindow;
    pub fn xrd_window_new_from_native(
        client: *mut XrdClient,
        title: *const c_char,
        native: gpointer,
        width_pixels: u32,
        height_pixels: u32,
        ppm: c_float,
    ) -> *mut XrdWindow;
    pub fn xrd_window_new_from_pixels(
        client: *mut XrdClient,
        title: *const c_char,
        width: u32,
        height: u32,
        ppm: c_float,
    ) -> *mut XrdWindow;
    pub fn xrd_window_add_child(
        self_: *mut XrdWindow,
        child: *mut XrdWindow,
        offset_center: *mut graphene::graphene_point_t,
    );
    pub fn xrd_window_close(self_: *mut XrdWindow);
    pub fn xrd_window_deselect(self_: *mut XrdWindow);
    pub fn xrd_window_emit_grab(self_: *mut XrdWindow, event: *mut XrdGrabEvent);
    pub fn xrd_window_emit_grab_start(self_: *mut XrdWindow, controller: *mut gxr::GxrController);
    pub fn xrd_window_emit_hover(self_: *mut XrdWindow, event: *mut XrdHoverEvent);
    pub fn xrd_window_emit_hover_end(self_: *mut XrdWindow, controller: *mut gxr::GxrController);
    pub fn xrd_window_emit_hover_start(self_: *mut XrdWindow, controller: *mut gxr::GxrController);
    pub fn xrd_window_emit_release(self_: *mut XrdWindow, controller: *mut gxr::GxrController);
    pub fn xrd_window_end_selection(self_: *mut XrdWindow);
    pub fn xrd_window_get_aspect_ratio(self_: *mut XrdWindow) -> c_float;
    pub fn xrd_window_get_current_height_meters(self_: *mut XrdWindow) -> c_float;
    pub fn xrd_window_get_current_ppm(self_: *mut XrdWindow) -> c_float;
    pub fn xrd_window_get_current_width_meters(self_: *mut XrdWindow) -> c_float;
    pub fn xrd_window_get_data(self_: *mut XrdWindow) -> *mut XrdWindowData;
    pub fn xrd_window_get_initial_ppm(self_: *mut XrdWindow) -> c_float;
    pub fn xrd_window_get_intersection_2d(
        self_: *mut XrdWindow,
        intersection_3d: *mut graphene::graphene_point3d_t,
        intersection_2d: *mut graphene::graphene_point_t,
    );
    pub fn xrd_window_get_intersection_2d_pixels(
        self_: *mut XrdWindow,
        intersection_3d: *mut graphene::graphene_point3d_t,
        intersection_pixels: *mut graphene::graphene_point_t,
    );
    pub fn xrd_window_get_normal(self_: *mut XrdWindow, normal: *mut graphene::graphene_vec3_t);
    pub fn xrd_window_get_plane(self_: *mut XrdWindow, res: *mut graphene::graphene_plane_t);
    pub fn xrd_window_get_reset_transformation(
        self_: *mut XrdWindow,
        transform: *mut graphene::graphene_matrix_t,
    );
    pub fn xrd_window_get_texture(self_: *mut XrdWindow) -> *mut gulkan::GulkanTexture;
    pub fn xrd_window_get_transformation(
        self_: *mut XrdWindow,
        mat: *mut graphene::graphene_matrix_t,
    ) -> gboolean;
    pub fn xrd_window_get_transformation_no_scale(
        self_: *mut XrdWindow,
        mat: *mut graphene::graphene_matrix_t,
    ) -> gboolean;
    pub fn xrd_window_hide(self_: *mut XrdWindow);
    pub fn xrd_window_is_pinned(self_: *mut XrdWindow) -> gboolean;
    pub fn xrd_window_is_selected(self_: *mut XrdWindow) -> gboolean;
    pub fn xrd_window_is_visible(self_: *mut XrdWindow) -> gboolean;
    pub fn xrd_window_poll_event(self_: *mut XrdWindow);
    pub fn xrd_window_save_reset_transformation(self_: *mut XrdWindow);
    pub fn xrd_window_select(self_: *mut XrdWindow);
    pub fn xrd_window_set_and_submit_texture(
        self_: *mut XrdWindow,
        texture: *mut gulkan::GulkanTexture,
    );
    pub fn xrd_window_set_color(self_: *mut XrdWindow, color: *const graphene::graphene_vec3_t);
    pub fn xrd_window_set_flip_y(self_: *mut XrdWindow, flip_y: gboolean);
    pub fn xrd_window_set_pin(self_: *mut XrdWindow, pinned: gboolean, hide_unpinned: gboolean);
    pub fn xrd_window_set_reset_transformation(
        self_: *mut XrdWindow,
        transform: *mut graphene::graphene_matrix_t,
    );
    pub fn xrd_window_set_transformation(
        self_: *mut XrdWindow,
        mat: *mut graphene::graphene_matrix_t,
    ) -> gboolean;
    pub fn xrd_window_show(self_: *mut XrdWindow);
    pub fn xrd_window_submit_texture(self_: *mut XrdWindow);
    pub fn xrd_window_update_child(self_: *mut XrdWindow);

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn xrd_button_set_icon(
        button: *mut XrdWindow,
        client: *mut gulkan::GulkanClient,
        upload_layout: u32,
        url: *const c_char,
    );
    pub fn xrd_button_set_text(
        button: *mut XrdWindow,
        client: *mut gulkan::GulkanClient,
        upload_layout: u32,
        label_count: c_int,
        label: *mut *mut c_char,
    );
    pub fn xrd_math_clamp_towards_zero_2d(
        min: *mut graphene::graphene_point_t,
        max: *mut graphene::graphene_point_t,
        point: *mut graphene::graphene_point_t,
        clamped: *mut graphene::graphene_point_t,
    ) -> gboolean;
    pub fn xrd_math_get_rotation_angles(
        direction: *mut graphene::graphene_vec3_t,
        azimuth: *mut c_float,
        inclination: *mut c_float,
    );
    pub fn xrd_math_intersect_lines_2d(
        p0: *mut graphene::graphene_point_t,
        p1: *mut graphene::graphene_point_t,
        p2: *mut graphene::graphene_point_t,
        p3: *mut graphene::graphene_point_t,
        intersection: *mut graphene::graphene_point_t,
    ) -> gboolean;
    pub fn xrd_math_matrix_set_translation_point(
        matrix: *mut graphene::graphene_matrix_t,
        point: *mut graphene::graphene_point3d_t,
    );
    pub fn xrd_math_matrix_set_translation_vec(
        matrix: *mut graphene::graphene_matrix_t,
        vec: *mut graphene::graphene_vec3_t,
    );
    pub fn xrd_math_point_matrix_distance(
        intersection_point: *mut graphene::graphene_point3d_t,
        pose: *mut graphene::graphene_matrix_t,
    ) -> c_float;
    pub fn xrd_math_sphere_to_3d_coords(
        azimuth: c_float,
        inclination: c_float,
        distance: c_float,
        point: *mut graphene::graphene_point3d_t,
    );
    pub fn xrd_render_lock();
    pub fn xrd_render_lock_destroy();
    pub fn xrd_render_lock_init();
    pub fn xrd_render_unlock();
    pub fn xrd_settings_connect_and_apply(
        callback: gobject::GCallback,
        key: *mut c_char,
        data: gpointer,
    );
    pub fn xrd_settings_destroy_instance();
    pub fn xrd_settings_get_instance() -> *mut gio::GSettings;
    pub fn xrd_settings_is_schema_installed() -> gboolean;
    pub fn xrd_settings_update_double_val(
        settings: *mut gio::GSettings,
        key: *mut c_char,
        val: *mut c_double,
    );
    pub fn xrd_settings_update_gboolean_val(
        settings: *mut gio::GSettings,
        key: *mut c_char,
        val: *mut gboolean,
    );
    pub fn xrd_settings_update_int_val(
        settings: *mut gio::GSettings,
        key: *mut c_char,
        val: *mut c_int,
    );

}

pub const SCHEMA: &'static str =
    include_str!(concat!(env!("OUT_DIR"), "/xrd/share/glib-2.0/schemas/org.xrdesktop.gschema.xml"));
