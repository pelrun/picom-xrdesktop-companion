// Generated by gir (https://github.com/gtk-rs/gir @ 2358cc24efd2)
// from ../gir-files (@ eab91ba8f88b)
// from ../xrd-gir-files (@ 82da2b8bb0f0+)
// DO NOT EDIT

use crate::Client;
use glib::{
    prelude::*,
    signal::{connect_raw, SignalHandlerId},
    translate::*,
};
use std::{boxed::Box as Box_, fmt, mem::transmute};

glib::wrapper! {
    #[doc(alias = "XrdWindow")]
    pub struct Window(Interface<ffi::XrdWindow, ffi::XrdWindowInterface>);

    match fn {
        type_ => || ffi::xrd_window_get_type(),
    }
}

impl Window {
    pub const NONE: Option<&'static Window> = None;

    //#[doc(alias = "xrd_window_new_from_data")]
    //pub fn new_from_data(self_: &impl IsA<Client>, data: /*Ignored*/&mut WindowData) -> Option<Window> {
    //    unsafe { TODO: call ffi:xrd_window_new_from_data() }
    //}

    /// ## `client`
    /// a [`Client`][crate::Client]
    /// ## `title`
    /// the title
    /// ## `width`
    /// the width
    /// ## `height`
    /// the height
    /// ## `ppm`
    /// the ppm
    ///
    /// # Returns
    ///
    /// a new [`Window`][crate::Window]
    #[doc(alias = "xrd_window_new_from_meters")]
    pub fn new_from_meters(
        client: &impl IsA<Client>,
        title: &str,
        width: f32,
        height: f32,
        ppm: f32,
    ) -> Option<Window> {
        unsafe {
            from_glib_full(ffi::xrd_window_new_from_meters(
                client.as_ref().to_glib_none().0,
                title.to_glib_none().0,
                width,
                height,
                ppm,
            ))
        }
    }

    //#[doc(alias = "xrd_window_new_from_native")]
    //pub fn new_from_native(client: &impl IsA<Client>, title: &str, native: /*Unimplemented*/Option<Basic: Pointer>, width_pixels: u32, height_pixels: u32, ppm: f32) -> Option<Window> {
    //    unsafe { TODO: call ffi:xrd_window_new_from_native() }
    //}

    /// ## `client`
    /// a [`Client`][crate::Client]
    /// ## `title`
    /// the title
    /// ## `width`
    /// the width
    /// ## `height`
    /// the height
    /// ## `ppm`
    /// the ppm
    ///
    /// # Returns
    ///
    /// a new [`Window`][crate::Window]
    #[doc(alias = "xrd_window_new_from_pixels")]
    pub fn new_from_pixels(
        client: &impl IsA<Client>,
        title: &str,
        width: u32,
        height: u32,
        ppm: f32,
    ) -> Option<Window> {
        unsafe {
            from_glib_full(ffi::xrd_window_new_from_pixels(
                client.as_ref().to_glib_none().0,
                title.to_glib_none().0,
                width,
                height,
                ppm,
            ))
        }
    }
}

unsafe impl Send for Window {}

/// Trait containing all [`struct@Window`] methods.
///
/// # Implementors
///
/// [`Window`][struct@crate::Window]
pub trait WindowExt: 'static {
    /// x axis points right, y axis points up.
    /// ## `child`
    /// An already existing window.
    /// ## `offset_center`
    /// The offset of the child window's center to the parent
    /// window's center in pixels.
    #[doc(alias = "xrd_window_add_child")]
    fn add_child(&self, child: &impl IsA<Window>, offset_center: &mut graphene::Point);

    #[doc(alias = "xrd_window_close")]
    fn close(&self);

    #[doc(alias = "xrd_window_deselect")]
    fn deselect(&self);

    //#[doc(alias = "xrd_window_emit_grab")]
    //fn emit_grab(&self, event: /*Ignored*/&mut GrabEvent);

    #[doc(alias = "xrd_window_emit_grab_start")]
    fn emit_grab_start(&self, controller: &gxr::Controller);

    //#[doc(alias = "xrd_window_emit_hover")]
    //fn emit_hover(&self, event: /*Ignored*/&mut HoverEvent);

    #[doc(alias = "xrd_window_emit_hover_end")]
    fn emit_hover_end(&self, controller: &gxr::Controller);

    #[doc(alias = "xrd_window_emit_hover_start")]
    fn emit_hover_start(&self, controller: &gxr::Controller);

    #[doc(alias = "xrd_window_emit_release")]
    fn emit_release(&self, controller: &gxr::Controller);

    #[doc(alias = "xrd_window_end_selection")]
    fn end_selection(&self);

    #[doc(alias = "xrd_window_get_aspect_ratio")]
    #[doc(alias = "get_aspect_ratio")]
    fn aspect_ratio(&self) -> f32;

    ///
    /// # Returns
    ///
    /// The current world space height of the window in meters.
    #[doc(alias = "xrd_window_get_current_height_meters")]
    #[doc(alias = "get_current_height_meters")]
    fn current_height_meters(&self) -> f32;

    #[doc(alias = "xrd_window_get_current_ppm")]
    #[doc(alias = "get_current_ppm")]
    fn current_ppm(&self) -> f32;

    ///
    /// # Returns
    ///
    /// The current world space width of the window in meters.
    #[doc(alias = "xrd_window_get_current_width_meters")]
    #[doc(alias = "get_current_width_meters")]
    fn current_width_meters(&self) -> f32;

    //#[doc(alias = "xrd_window_get_data")]
    //#[doc(alias = "get_data")]
    //fn data(&self) -> /*Ignored*/Option<WindowData>;

    #[doc(alias = "xrd_window_get_initial_ppm")]
    #[doc(alias = "get_initial_ppm")]
    fn initial_ppm(&self) -> f32;

    /// Calculates the offset of the intersection relative to the overlay's center,
    /// in overlay-relative coordinates, in meters
    /// ## `intersection_3d`
    /// A [`graphene::Point3D`][crate::graphene::Point3D] intersection point in meters.
    /// ## `intersection_2d`
    /// Intersection in window coordinates with origin at center in meters.
    #[doc(alias = "xrd_window_get_intersection_2d")]
    #[doc(alias = "get_intersection_2d")]
    fn intersection_2d(
        &self,
        intersection_3d: &mut graphene::Point3D,
        intersection_2d: &mut graphene::Point,
    );

    /// ## `intersection_3d`
    /// A [`graphene::Point3D`][crate::graphene::Point3D] intersection point in meters.
    /// ## `intersection_pixels`
    /// Intersection in window coordinates with the origin at top/left in pixels.
    #[doc(alias = "xrd_window_get_intersection_2d_pixels")]
    #[doc(alias = "get_intersection_2d_pixels")]
    fn intersection_2d_pixels(
        &self,
        intersection_3d: &mut graphene::Point3D,
        intersection_pixels: &mut graphene::Point,
    );

    //#[doc(alias = "xrd_window_get_normal")]
    //#[doc(alias = "get_normal")]
    //fn normal(&self, normal: /*Ignored*/&mut graphene::Vec3);

    //#[doc(alias = "xrd_window_get_plane")]
    //#[doc(alias = "get_plane")]
    //fn plane(&self, res: /*Ignored*/&mut graphene::Plane);

    #[doc(alias = "xrd_window_get_reset_transformation")]
    #[doc(alias = "get_reset_transformation")]
    fn reset_transformation(&self, transform: &mut graphene::Matrix);

    ///
    /// # Returns
    ///
    /// The last [`gulkan::Texture`][crate::gulkan::Texture] submitted with
    /// [`submit_texture()`][Self::submit_texture()], or [`None`] if none has been submitted so far.
    #[doc(alias = "xrd_window_get_texture")]
    #[doc(alias = "get_texture")]
    fn texture(&self) -> Option<gulkan::Texture>;

    #[doc(alias = "xrd_window_get_transformation")]
    #[doc(alias = "get_transformation")]
    fn is_transformation(&self, mat: &mut graphene::Matrix) -> bool;

    #[doc(alias = "xrd_window_get_transformation_no_scale")]
    #[doc(alias = "get_transformation_no_scale")]
    fn is_transformation_no_scale(&self, mat: &mut graphene::Matrix) -> bool;

    #[doc(alias = "xrd_window_hide")]
    fn hide(&self);

    #[doc(alias = "xrd_window_is_pinned")]
    fn is_pinned(&self) -> bool;

    #[doc(alias = "xrd_window_is_selected")]
    fn is_selected(&self) -> bool;

    #[doc(alias = "xrd_window_is_visible")]
    fn is_visible(&self) -> bool;

    /// Must be called periodically to receive events from this window.
    #[doc(alias = "xrd_window_poll_event")]
    fn poll_event(&self);

    #[doc(alias = "xrd_window_save_reset_transformation")]
    fn save_reset_transformation(&self);

    #[doc(alias = "xrd_window_select")]
    fn select(&self);

    /// For performance reason it is a good idea to not set a new texture every
    /// time the window content changes. Instead the the cached texture should be
    /// acquired with [`texture()`][Self::texture()] and resubmitted with
    /// [`submit_texture()`][Self::submit_texture()]..
    /// If the window/texture size changes, a new texture should be submitted
    /// (the previous submitted texture does not need to be unref'ed).
    ///
    /// This function also submits the `texture`.
    /// ## `texture`
    /// A [`gulkan::Texture`][crate::gulkan::Texture] that is created by the caller.
    /// Ownership of this texture is transferred to the [`Window`][crate::Window].
    #[doc(alias = "xrd_window_set_and_submit_texture")]
    fn set_and_submit_texture(&self, texture: gulkan::Texture);

    //#[doc(alias = "xrd_window_set_color")]
    //fn set_color(&self, color: /*Ignored*/&graphene::Vec3);

    #[doc(alias = "xrd_window_set_flip_y")]
    fn set_flip_y(&self, flip_y: bool);

    /// ## `pinned`
    /// The pin status to set this window to
    /// ## `hide_unpinned`
    /// If TRUE, the window will be hidden if it is unpinned, and
    /// shown if it is pinned. This corresponds to the "show only pinned windows"
    /// mode set up in [`Client`][crate::Client].
    /// If FALSE, windows are always shown.
    /// Note that `hide_unpinned` only determines initial visibility, and does not
    /// keep track of further mode changes.
    #[doc(alias = "xrd_window_set_pin")]
    fn set_pin(&self, pinned: bool, hide_unpinned: bool);

    /// ## `transform`
    /// A transformation matrix to save as reset transform.
    #[doc(alias = "xrd_window_set_reset_transformation")]
    fn set_reset_transformation(&self, transform: &mut graphene::Matrix);

    /// Sets the sort order of the window. Only works for overlay windows, has no effect
    /// on scene windows, returns true if the sort order was changed. Will return false for
    /// scene windows.
    #[doc(alias = "xrd_window_set_sort_order")]
    fn set_sort_order(&self, sort_order: u32) -> bool;

    #[doc(alias = "xrd_window_set_transformation")]
    fn set_transformation(&self, mat: &mut graphene::Matrix) -> bool;

    #[doc(alias = "xrd_window_show")]
    fn show(&self);

    #[doc(alias = "xrd_window_submit_texture")]
    fn submit_texture(&self);

    #[doc(alias = "xrd_window_update_child")]
    fn update_child(&self);

    #[doc(alias = "initial-height-meters")]
    fn initial_height_meters(&self) -> f32;

    #[doc(alias = "initial-height-meters")]
    fn set_initial_height_meters(&self, initial_height_meters: f32);

    #[doc(alias = "initial-width-meters")]
    fn initial_width_meters(&self) -> f32;

    #[doc(alias = "initial-width-meters")]
    fn set_initial_width_meters(&self, initial_width_meters: f32);

    //fn native(&self) -> /*Unimplemented*/Basic: Pointer;

    //fn set_native(&self, native: /*Unimplemented*/Basic: Pointer);

    fn scale(&self) -> f32;

    fn set_scale(&self, scale: f32);

    #[doc(alias = "texture-height")]
    fn texture_height(&self) -> u32;

    #[doc(alias = "texture-height")]
    fn set_texture_height(&self, texture_height: u32);

    #[doc(alias = "texture-width")]
    fn texture_width(&self) -> u32;

    #[doc(alias = "texture-width")]
    fn set_texture_width(&self, texture_width: u32);

    fn title(&self) -> Option<glib::GString>;

    #[doc(alias = "button-press-event")]
    fn connect_button_press_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[doc(alias = "button-release-event")]
    fn connect_button_release_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[doc(alias = "destroy")]
    fn connect_destroy<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "grab-event")]
    fn connect_grab_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[doc(alias = "grab-start-event")]
    fn connect_grab_start_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[doc(alias = "hover-end-event")]
    fn connect_hover_end_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[doc(alias = "hover-event")]
    fn connect_hover_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[doc(alias = "hover-start-event")]
    fn connect_hover_start_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[doc(alias = "keyboard-close-event")]
    fn connect_keyboard_close_event<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "keyboard-press-event")]
    fn connect_keyboard_press_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[doc(alias = "motion-notify-event")]
    fn connect_motion_notify_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[doc(alias = "release-event")]
    fn connect_release_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[doc(alias = "scroll-event")]
    fn connect_scroll_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[doc(alias = "show")]
    fn connect_show<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "initial-height-meters")]
    fn connect_initial_height_meters_notify<F: Fn(&Self) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[doc(alias = "initial-width-meters")]
    fn connect_initial_width_meters_notify<F: Fn(&Self) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[doc(alias = "native")]
    fn connect_native_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "scale")]
    fn connect_scale_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "texture-height")]
    fn connect_texture_height_notify<F: Fn(&Self) + Send + 'static>(&self, f: F)
        -> SignalHandlerId;

    #[doc(alias = "texture-width")]
    fn connect_texture_width_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Window>> WindowExt for O {
    fn add_child(&self, child: &impl IsA<Window>, offset_center: &mut graphene::Point) {
        unsafe {
            ffi::xrd_window_add_child(
                self.as_ref().to_glib_none().0,
                child.as_ref().to_glib_none().0,
                offset_center.to_glib_none_mut().0,
            );
        }
    }

    fn close(&self) {
        unsafe {
            ffi::xrd_window_close(self.as_ref().to_glib_none().0);
        }
    }

    fn deselect(&self) {
        unsafe {
            ffi::xrd_window_deselect(self.as_ref().to_glib_none().0);
        }
    }

    //fn emit_grab(&self, event: /*Ignored*/&mut GrabEvent) {
    //    unsafe { TODO: call ffi:xrd_window_emit_grab() }
    //}

    fn emit_grab_start(&self, controller: &gxr::Controller) {
        unsafe {
            ffi::xrd_window_emit_grab_start(
                self.as_ref().to_glib_none().0,
                controller.to_glib_none().0,
            );
        }
    }

    //fn emit_hover(&self, event: /*Ignored*/&mut HoverEvent) {
    //    unsafe { TODO: call ffi:xrd_window_emit_hover() }
    //}

    fn emit_hover_end(&self, controller: &gxr::Controller) {
        unsafe {
            ffi::xrd_window_emit_hover_end(
                self.as_ref().to_glib_none().0,
                controller.to_glib_none().0,
            );
        }
    }

    fn emit_hover_start(&self, controller: &gxr::Controller) {
        unsafe {
            ffi::xrd_window_emit_hover_start(
                self.as_ref().to_glib_none().0,
                controller.to_glib_none().0,
            );
        }
    }

    fn emit_release(&self, controller: &gxr::Controller) {
        unsafe {
            ffi::xrd_window_emit_release(
                self.as_ref().to_glib_none().0,
                controller.to_glib_none().0,
            );
        }
    }

    fn end_selection(&self) {
        unsafe {
            ffi::xrd_window_end_selection(self.as_ref().to_glib_none().0);
        }
    }

    fn aspect_ratio(&self) -> f32 {
        unsafe { ffi::xrd_window_get_aspect_ratio(self.as_ref().to_glib_none().0) }
    }

    fn current_height_meters(&self) -> f32 {
        unsafe { ffi::xrd_window_get_current_height_meters(self.as_ref().to_glib_none().0) }
    }

    fn current_ppm(&self) -> f32 {
        unsafe { ffi::xrd_window_get_current_ppm(self.as_ref().to_glib_none().0) }
    }

    fn current_width_meters(&self) -> f32 {
        unsafe { ffi::xrd_window_get_current_width_meters(self.as_ref().to_glib_none().0) }
    }

    //fn data(&self) -> /*Ignored*/Option<WindowData> {
    //    unsafe { TODO: call ffi:xrd_window_get_data() }
    //}

    fn initial_ppm(&self) -> f32 {
        unsafe { ffi::xrd_window_get_initial_ppm(self.as_ref().to_glib_none().0) }
    }

    fn intersection_2d(
        &self,
        intersection_3d: &mut graphene::Point3D,
        intersection_2d: &mut graphene::Point,
    ) {
        unsafe {
            ffi::xrd_window_get_intersection_2d(
                self.as_ref().to_glib_none().0,
                intersection_3d.to_glib_none_mut().0,
                intersection_2d.to_glib_none_mut().0,
            );
        }
    }

    fn intersection_2d_pixels(
        &self,
        intersection_3d: &mut graphene::Point3D,
        intersection_pixels: &mut graphene::Point,
    ) {
        unsafe {
            ffi::xrd_window_get_intersection_2d_pixels(
                self.as_ref().to_glib_none().0,
                intersection_3d.to_glib_none_mut().0,
                intersection_pixels.to_glib_none_mut().0,
            );
        }
    }

    //fn normal(&self, normal: /*Ignored*/&mut graphene::Vec3) {
    //    unsafe { TODO: call ffi:xrd_window_get_normal() }
    //}

    //fn plane(&self, res: /*Ignored*/&mut graphene::Plane) {
    //    unsafe { TODO: call ffi:xrd_window_get_plane() }
    //}

    fn reset_transformation(&self, transform: &mut graphene::Matrix) {
        unsafe {
            ffi::xrd_window_get_reset_transformation(
                self.as_ref().to_glib_none().0,
                transform.to_glib_none_mut().0,
            );
        }
    }

    fn texture(&self) -> Option<gulkan::Texture> {
        unsafe { from_glib_none(ffi::xrd_window_get_texture(self.as_ref().to_glib_none().0)) }
    }

    fn is_transformation(&self, mat: &mut graphene::Matrix) -> bool {
        unsafe {
            from_glib(ffi::xrd_window_get_transformation(
                self.as_ref().to_glib_none().0,
                mat.to_glib_none_mut().0,
            ))
        }
    }

    fn is_transformation_no_scale(&self, mat: &mut graphene::Matrix) -> bool {
        unsafe {
            from_glib(ffi::xrd_window_get_transformation_no_scale(
                self.as_ref().to_glib_none().0,
                mat.to_glib_none_mut().0,
            ))
        }
    }

    fn hide(&self) {
        unsafe {
            ffi::xrd_window_hide(self.as_ref().to_glib_none().0);
        }
    }

    fn is_pinned(&self) -> bool {
        unsafe { from_glib(ffi::xrd_window_is_pinned(self.as_ref().to_glib_none().0)) }
    }

    fn is_selected(&self) -> bool {
        unsafe { from_glib(ffi::xrd_window_is_selected(self.as_ref().to_glib_none().0)) }
    }

    fn is_visible(&self) -> bool {
        unsafe { from_glib(ffi::xrd_window_is_visible(self.as_ref().to_glib_none().0)) }
    }

    fn poll_event(&self) {
        unsafe {
            ffi::xrd_window_poll_event(self.as_ref().to_glib_none().0);
        }
    }

    fn save_reset_transformation(&self) {
        unsafe {
            ffi::xrd_window_save_reset_transformation(self.as_ref().to_glib_none().0);
        }
    }

    fn select(&self) {
        unsafe {
            ffi::xrd_window_select(self.as_ref().to_glib_none().0);
        }
    }

    fn set_and_submit_texture(&self, texture: gulkan::Texture) {
        unsafe {
            ffi::xrd_window_set_and_submit_texture(
                self.as_ref().to_glib_none().0,
                texture.into_glib_ptr(),
            );
        }
    }

    //fn set_color(&self, color: /*Ignored*/&graphene::Vec3) {
    //    unsafe { TODO: call ffi:xrd_window_set_color() }
    //}

    fn set_flip_y(&self, flip_y: bool) {
        unsafe {
            ffi::xrd_window_set_flip_y(self.as_ref().to_glib_none().0, flip_y.into_glib());
        }
    }

    fn set_pin(&self, pinned: bool, hide_unpinned: bool) {
        unsafe {
            ffi::xrd_window_set_pin(
                self.as_ref().to_glib_none().0,
                pinned.into_glib(),
                hide_unpinned.into_glib(),
            );
        }
    }

    fn set_reset_transformation(&self, transform: &mut graphene::Matrix) {
        unsafe {
            ffi::xrd_window_set_reset_transformation(
                self.as_ref().to_glib_none().0,
                transform.to_glib_none_mut().0,
            );
        }
    }

    fn set_sort_order(&self, sort_order: u32) -> bool {
        unsafe {
            from_glib(ffi::xrd_window_set_sort_order(
                self.as_ref().to_glib_none().0,
                sort_order,
            ))
        }
    }

    fn set_transformation(&self, mat: &mut graphene::Matrix) -> bool {
        unsafe {
            from_glib(ffi::xrd_window_set_transformation(
                self.as_ref().to_glib_none().0,
                mat.to_glib_none_mut().0,
            ))
        }
    }

    fn show(&self) {
        unsafe {
            ffi::xrd_window_show(self.as_ref().to_glib_none().0);
        }
    }

    fn submit_texture(&self) {
        unsafe {
            ffi::xrd_window_submit_texture(self.as_ref().to_glib_none().0);
        }
    }

    fn update_child(&self) {
        unsafe {
            ffi::xrd_window_update_child(self.as_ref().to_glib_none().0);
        }
    }

    fn initial_height_meters(&self) -> f32 {
        glib::ObjectExt::property(self.as_ref(), "initial-height-meters")
    }

    fn set_initial_height_meters(&self, initial_height_meters: f32) {
        glib::ObjectExt::set_property(
            self.as_ref(),
            "initial-height-meters",
            initial_height_meters,
        )
    }

    fn initial_width_meters(&self) -> f32 {
        glib::ObjectExt::property(self.as_ref(), "initial-width-meters")
    }

    fn set_initial_width_meters(&self, initial_width_meters: f32) {
        glib::ObjectExt::set_property(self.as_ref(), "initial-width-meters", initial_width_meters)
    }

    //fn native(&self) -> /*Unimplemented*/Basic: Pointer {
    //    glib::ObjectExt::property(self.as_ref(), "native")
    //}

    //fn set_native(&self, native: /*Unimplemented*/Basic: Pointer) {
    //    glib::ObjectExt::set_property(self.as_ref(),"native", native)
    //}

    fn scale(&self) -> f32 {
        glib::ObjectExt::property(self.as_ref(), "scale")
    }

    fn set_scale(&self, scale: f32) {
        glib::ObjectExt::set_property(self.as_ref(), "scale", scale)
    }

    fn texture_height(&self) -> u32 {
        glib::ObjectExt::property(self.as_ref(), "texture-height")
    }

    fn set_texture_height(&self, texture_height: u32) {
        glib::ObjectExt::set_property(self.as_ref(), "texture-height", texture_height)
    }

    fn texture_width(&self) -> u32 {
        glib::ObjectExt::property(self.as_ref(), "texture-width")
    }

    fn set_texture_width(&self, texture_width: u32) {
        glib::ObjectExt::set_property(self.as_ref(), "texture-width", texture_width)
    }

    fn title(&self) -> Option<glib::GString> {
        glib::ObjectExt::property(self.as_ref(), "title")
    }

    fn connect_button_press_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn button_press_event_trampoline<
            P: IsA<Window>,
            F: Fn(&P, &gdk::Event) + Send + 'static,
        >(
            this: *mut ffi::XrdWindow,
            object: *mut gdk::ffi::GdkEvent,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(
                Window::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_none(object),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"button-press-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    button_press_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_button_release_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn button_release_event_trampoline<
            P: IsA<Window>,
            F: Fn(&P, &gdk::Event) + Send + 'static,
        >(
            this: *mut ffi::XrdWindow,
            object: *mut gdk::ffi::GdkEvent,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(
                Window::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_none(object),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"button-release-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    button_release_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_destroy<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn destroy_trampoline<P: IsA<Window>, F: Fn(&P) + Send + 'static>(
            this: *mut ffi::XrdWindow,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"destroy\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    destroy_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_grab_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn grab_event_trampoline<
            P: IsA<Window>,
            F: Fn(&P, &gdk::Event) + Send + 'static,
        >(
            this: *mut ffi::XrdWindow,
            object: *mut gdk::ffi::GdkEvent,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(
                Window::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_none(object),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"grab-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    grab_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_grab_start_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn grab_start_event_trampoline<
            P: IsA<Window>,
            F: Fn(&P, &gdk::Event) + Send + 'static,
        >(
            this: *mut ffi::XrdWindow,
            object: *mut gdk::ffi::GdkEvent,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(
                Window::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_none(object),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"grab-start-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    grab_start_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_hover_end_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn hover_end_event_trampoline<
            P: IsA<Window>,
            F: Fn(&P, &gdk::Event) + Send + 'static,
        >(
            this: *mut ffi::XrdWindow,
            object: *mut gdk::ffi::GdkEvent,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(
                Window::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_none(object),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"hover-end-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    hover_end_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_hover_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn hover_event_trampoline<
            P: IsA<Window>,
            F: Fn(&P, &gdk::Event) + Send + 'static,
        >(
            this: *mut ffi::XrdWindow,
            object: *mut gdk::ffi::GdkEvent,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(
                Window::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_none(object),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"hover-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    hover_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_hover_start_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn hover_start_event_trampoline<
            P: IsA<Window>,
            F: Fn(&P, &gdk::Event) + Send + 'static,
        >(
            this: *mut ffi::XrdWindow,
            object: *mut gdk::ffi::GdkEvent,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(
                Window::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_none(object),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"hover-start-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    hover_start_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_keyboard_close_event<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn keyboard_close_event_trampoline<
            P: IsA<Window>,
            F: Fn(&P) + Send + 'static,
        >(
            this: *mut ffi::XrdWindow,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"keyboard-close-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    keyboard_close_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_keyboard_press_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn keyboard_press_event_trampoline<
            P: IsA<Window>,
            F: Fn(&P, &gdk::Event) + Send + 'static,
        >(
            this: *mut ffi::XrdWindow,
            object: *mut gdk::ffi::GdkEvent,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(
                Window::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_none(object),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"keyboard-press-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    keyboard_press_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_motion_notify_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn motion_notify_event_trampoline<
            P: IsA<Window>,
            F: Fn(&P, &gdk::Event) + Send + 'static,
        >(
            this: *mut ffi::XrdWindow,
            object: *mut gdk::ffi::GdkEvent,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(
                Window::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_none(object),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"motion-notify-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    motion_notify_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_release_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn release_event_trampoline<
            P: IsA<Window>,
            F: Fn(&P, &gdk::Event) + Send + 'static,
        >(
            this: *mut ffi::XrdWindow,
            object: *mut gdk::ffi::GdkEvent,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(
                Window::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_none(object),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"release-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    release_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_scroll_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn scroll_event_trampoline<
            P: IsA<Window>,
            F: Fn(&P, &gdk::Event) + Send + 'static,
        >(
            this: *mut ffi::XrdWindow,
            object: *mut gdk::ffi::GdkEvent,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(
                Window::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_none(object),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"scroll-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    scroll_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_show<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn show_trampoline<P: IsA<Window>, F: Fn(&P) + Send + 'static>(
            this: *mut ffi::XrdWindow,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"show\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    show_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_initial_height_meters_notify<F: Fn(&Self) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_initial_height_meters_trampoline<
            P: IsA<Window>,
            F: Fn(&P) + Send + 'static,
        >(
            this: *mut ffi::XrdWindow,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::initial-height-meters\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_initial_height_meters_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_initial_width_meters_notify<F: Fn(&Self) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_initial_width_meters_trampoline<
            P: IsA<Window>,
            F: Fn(&P) + Send + 'static,
        >(
            this: *mut ffi::XrdWindow,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::initial-width-meters\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_initial_width_meters_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_native_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_native_trampoline<
            P: IsA<Window>,
            F: Fn(&P) + Send + 'static,
        >(
            this: *mut ffi::XrdWindow,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::native\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_native_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_scale_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_scale_trampoline<P: IsA<Window>, F: Fn(&P) + Send + 'static>(
            this: *mut ffi::XrdWindow,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::scale\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_scale_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_texture_height_notify<F: Fn(&Self) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_texture_height_trampoline<
            P: IsA<Window>,
            F: Fn(&P) + Send + 'static,
        >(
            this: *mut ffi::XrdWindow,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::texture-height\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_texture_height_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_texture_width_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_texture_width_trampoline<
            P: IsA<Window>,
            F: Fn(&P) + Send + 'static,
        >(
            this: *mut ffi::XrdWindow,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::texture-width\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_texture_width_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for Window {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Window")
    }
}
