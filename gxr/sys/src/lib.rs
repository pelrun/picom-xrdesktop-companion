// Generated by gir (https://github.com/gtk-rs/gir @ 2358cc24efd2)
// from ../../gir-files (@ eab91ba8f88b)
// from ../../xrd-gir-files (@ 3896faadf111)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(
    clippy::approx_constant,
    clippy::type_complexity,
    clippy::unreadable_literal,
    clippy::upper_case_acronyms
)]
#![cfg_attr(feature = "dox", feature(doc_cfg))]

#[allow(unused_imports)]
use libc::{
    c_char, c_double, c_float, c_int, c_long, c_short, c_uchar, c_uint, c_ulong, c_ushort, c_void,
    intptr_t, size_t, ssize_t, uintptr_t, FILE,
};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Enums
pub type GxrActionType = c_int;
pub const GXR_ACTION_DIGITAL: GxrActionType = 0;
pub const GXR_ACTION_DIGITAL_FROM_FLOAT: GxrActionType = 1;
pub const GXR_ACTION_VEC2F: GxrActionType = 2;
pub const GXR_ACTION_FLOAT: GxrActionType = 3;
pub const GXR_ACTION_POSE: GxrActionType = 4;
pub const GXR_ACTION_HAPTIC: GxrActionType = 5;

pub type GxrApi = c_int;
pub const GXR_API_OPENVR: GxrApi = 0;
pub const GXR_API_OPENXR: GxrApi = 1;
pub const GXR_API_NONE: GxrApi = 2;

pub type GxrAppType = c_int;
pub const GXR_APP_SCENE: GxrAppType = 0;
pub const GXR_APP_OVERLAY: GxrAppType = 1;
pub const GXR_APP_HEADLESS: GxrAppType = 2;

pub type GxrBindingComponent = c_int;
pub const GXR_BINDING_COMPONENT_NONE: GxrBindingComponent = 0;
pub const GXR_BINDING_COMPONENT_UNKNOWN: GxrBindingComponent = 1;
pub const GXR_BINDING_COMPONENT_CLICK: GxrBindingComponent = 2;
pub const GXR_BINDING_COMPONENT_PULL: GxrBindingComponent = 3;
pub const GXR_BINDING_COMPONENT_POSITION: GxrBindingComponent = 4;
pub const GXR_BINDING_COMPONENT_TOUCH: GxrBindingComponent = 5;
pub const GXR_BINDING_COMPONENT_FORCE: GxrBindingComponent = 6;

pub type GxrBindingMode = c_int;
pub const GXR_BINDING_MODE_NONE: GxrBindingMode = 0;
pub const GXR_BINDING_MODE_UNKNOWN: GxrBindingMode = 1;
pub const GXR_BINDING_MODE_BUTTON: GxrBindingMode = 2;
pub const GXR_BINDING_MODE_TRACKPAD: GxrBindingMode = 3;
pub const GXR_BINDING_MODE_ANALOG_STICK: GxrBindingMode = 4;

pub type GxrBindingType = c_int;
pub const GXR_BINDING_TYPE_UNKNOWN: GxrBindingType = 0;
pub const GXR_BINDING_TYPE_POSE: GxrBindingType = 1;
pub const GXR_BINDING_TYPE_BOOLEAN: GxrBindingType = 2;
pub const GXR_BINDING_TYPE_FLOAT: GxrBindingType = 3;
pub const GXR_BINDING_TYPE_VEC2: GxrBindingType = 4;
pub const GXR_BINDING_TYPE_HAPTIC: GxrBindingType = 5;

pub type GxrEye = c_int;
pub const GXR_EYE_LEFT: GxrEye = 0;
pub const GXR_EYE_RIGHT: GxrEye = 1;

pub type GxrQuitReason = c_int;
pub const GXR_QUIT_SHUTDOWN: GxrQuitReason = 0;
pub const GXR_QUIT_APPLICATION_TRANSITION: GxrQuitReason = 1;
pub const GXR_QUIT_PROCESS_QUIT: GxrQuitReason = 2;

pub type GxrTransformLock = c_int;
pub const GXR_TRANSFORM_LOCK_NONE: GxrTransformLock = 0;
pub const GXR_TRANSFORM_LOCK_PUSH_PULL: GxrTransformLock = 1;
pub const GXR_TRANSFORM_LOCK_SCALE: GxrTransformLock = 2;

// Constants
pub const GXR_DEVICE_INDEX_HMD: c_int = 0;
pub const GXR_DEVICE_INDEX_MAX: c_int = 64;
pub const GXR_MODEL_NAME_MAX: c_int = 32768;
pub const GXR_TIP_APPARENT_SIZE_DISTANCE: c_double = 3.000000;
pub const GXR_TIP_VIEWPORT_SCALE: c_int = 3;

// Records
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrActionClass {
    pub parent: gobject::GObjectClass,
    pub poll: Option<unsafe extern "C" fn(*mut GxrAction) -> gboolean>,
    pub trigger_haptic: Option<
        unsafe extern "C" fn(*mut GxrAction, c_float, c_float, c_float, c_float, u64) -> gboolean,
    >,
    pub set_digital_from_float_threshold: Option<unsafe extern "C" fn(*mut GxrAction, c_float)>,
    pub set_digital_from_float_haptic: Option<unsafe extern "C" fn(*mut GxrAction, *mut GxrAction)>,
}

impl ::std::fmt::Debug for GxrActionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrActionClass @ {self:p}"))
            .field("parent", &self.parent)
            .field("poll", &self.poll)
            .field("trigger_haptic", &self.trigger_haptic)
            .field(
                "set_digital_from_float_threshold",
                &self.set_digital_from_float_threshold,
            )
            .field(
                "set_digital_from_float_haptic",
                &self.set_digital_from_float_haptic,
            )
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrActionManifestEntry {
    pub name: *mut c_char,
    pub type_: GxrBindingType,
}

impl ::std::fmt::Debug for GxrActionManifestEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrActionManifestEntry @ {self:p}"))
            .field("name", &self.name)
            .field("type_", &self.type_)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrActionSetClass {
    pub parent: gobject::GObjectClass,
    pub update: Option<unsafe extern "C" fn(*mut *mut GxrActionSet, u32) -> gboolean>,
    pub create_action: Option<
        unsafe extern "C" fn(
            *mut GxrActionSet,
            *mut GxrContext,
            GxrActionType,
            *mut c_char,
        ) -> *mut GxrAction,
    >,
    pub attach_bindings:
        Option<unsafe extern "C" fn(*mut *mut GxrActionSet, *mut GxrContext, u32) -> gboolean>,
}

impl ::std::fmt::Debug for GxrActionSetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrActionSetClass @ {self:p}"))
            .field("parent", &self.parent)
            .field("update", &self.update)
            .field("create_action", &self.create_action)
            .field("attach_bindings", &self.attach_bindings)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrAnalogEvent {
    pub active: gboolean,
    pub controller: *mut GxrController,
    pub time: c_float,
}

impl ::std::fmt::Debug for GxrAnalogEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrAnalogEvent @ {self:p}"))
            .field("active", &self.active)
            .field("controller", &self.controller)
            .field("time", &self.time)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrBackendClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GxrBackendClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrBackendClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrBinding {
    pub action: *mut GxrActionManifestEntry,
    pub input_paths: *mut glib::GSList,
}

impl ::std::fmt::Debug for GxrBinding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrBinding @ {self:p}"))
            .field("action", &self.action)
            .field("input_paths", &self.input_paths)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrBindingManifest {
    pub filename: *mut c_char,
    pub gxr_bindings: *mut glib::GSList,
    pub interaction_profile: *mut c_char,
}

impl ::std::fmt::Debug for GxrBindingManifest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrBindingManifest @ {self:p}"))
            .field("filename", &self.filename)
            .field("gxr_bindings", &self.gxr_bindings)
            .field("interaction_profile", &self.interaction_profile)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrBindingPath {
    pub component: GxrBindingComponent,
    pub path: *mut c_char,
    pub mode: GxrBindingMode,
}

impl ::std::fmt::Debug for GxrBindingPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrBindingPath @ {self:p}"))
            .field("component", &self.component)
            .field("path", &self.path)
            .field("mode", &self.mode)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrContextClass {
    pub parent: gobject::GObjectClass,
    pub get_frustum_angles: Option<
        unsafe extern "C" fn(
            *mut GxrContext,
            GxrEye,
            *mut c_float,
            *mut c_float,
            *mut c_float,
            *mut c_float,
        ),
    >,
    pub is_input_available: Option<unsafe extern "C" fn(*mut GxrContext) -> gboolean>,
    pub poll_event: Option<unsafe extern "C" fn(*mut GxrContext)>,
    pub show_keyboard: Option<unsafe extern "C" fn(*mut GxrContext)>,
    pub init_runtime:
        Option<unsafe extern "C" fn(*mut GxrContext, GxrAppType, *mut c_char, u32) -> gboolean>,
    pub init_session: Option<unsafe extern "C" fn(*mut GxrContext) -> gboolean>,
    pub submit_framebuffers: Option<unsafe extern "C" fn(*mut GxrContext) -> gboolean>,
    pub get_model_vertex_stride: Option<unsafe extern "C" fn(*mut GxrContext) -> u32>,
    pub get_model_normal_offset: Option<unsafe extern "C" fn(*mut GxrContext) -> u32>,
    pub get_model_uv_offset: Option<unsafe extern "C" fn(*mut GxrContext) -> u32>,
    pub begin_frame: Option<unsafe extern "C" fn(*mut GxrContext, *mut GxrPose) -> gboolean>,
    pub end_frame: Option<unsafe extern "C" fn(*mut GxrContext) -> gboolean>,
    pub acknowledge_quit: Option<unsafe extern "C" fn(*mut GxrContext)>,
    pub is_tracked_device_connected: Option<unsafe extern "C" fn(*mut GxrContext, u32) -> gboolean>,
    pub device_is_controller: Option<unsafe extern "C" fn(*mut GxrContext, u32) -> gboolean>,
    pub get_device_model_name: Option<unsafe extern "C" fn(*mut GxrContext, u32) -> *mut c_char>,
    pub is_another_scene_running: Option<unsafe extern "C" fn(*mut GxrContext) -> gboolean>,
    pub load_action_manifest: Option<
        unsafe extern "C" fn(
            *mut GxrContext,
            *const c_char,
            *const c_char,
            *const c_char,
        ) -> gboolean,
    >,
    pub request_quit: Option<unsafe extern "C" fn(*mut GxrContext)>,
    pub get_instance_extensions:
        Option<unsafe extern "C" fn(*mut GxrContext, *mut *mut glib::GSList) -> gboolean>,
    pub get_view_count: Option<unsafe extern "C" fn(*mut GxrContext) -> u32>,
}

impl ::std::fmt::Debug for GxrContextClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrContextClass @ {self:p}"))
            .field("parent", &self.parent)
            .field("get_frustum_angles", &self.get_frustum_angles)
            .field("is_input_available", &self.is_input_available)
            .field("poll_event", &self.poll_event)
            .field("show_keyboard", &self.show_keyboard)
            .field("init_runtime", &self.init_runtime)
            .field("init_session", &self.init_session)
            .field("submit_framebuffers", &self.submit_framebuffers)
            .field("get_model_vertex_stride", &self.get_model_vertex_stride)
            .field("get_model_normal_offset", &self.get_model_normal_offset)
            .field("get_model_uv_offset", &self.get_model_uv_offset)
            .field("begin_frame", &self.begin_frame)
            .field("end_frame", &self.end_frame)
            .field("acknowledge_quit", &self.acknowledge_quit)
            .field(
                "is_tracked_device_connected",
                &self.is_tracked_device_connected,
            )
            .field("device_is_controller", &self.device_is_controller)
            .field("get_device_model_name", &self.get_device_model_name)
            .field("is_another_scene_running", &self.is_another_scene_running)
            .field("load_action_manifest", &self.load_action_manifest)
            .field("request_quit", &self.request_quit)
            .field("get_instance_extensions", &self.get_instance_extensions)
            .field("get_view_count", &self.get_view_count)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrControllerClass {
    pub parent_class: GxrDeviceClass,
}

impl ::std::fmt::Debug for GxrControllerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrControllerClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrDeviceClass {
    pub parent: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GxrDeviceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrDeviceClass @ {self:p}"))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrDeviceManagerClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GxrDeviceManagerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrDeviceManagerClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrDigitalEvent {
    pub active: gboolean,
    pub state: gboolean,
    pub changed: gboolean,
    pub controller: *mut GxrController,
    pub time: c_float,
}

impl ::std::fmt::Debug for GxrDigitalEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrDigitalEvent @ {self:p}"))
            .field("active", &self.active)
            .field("state", &self.state)
            .field("changed", &self.changed)
            .field("controller", &self.controller)
            .field("time", &self.time)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrGrabState {
    pub grabbed_object: gpointer,
    pub transform_lock: GxrTransformLock,
}

impl ::std::fmt::Debug for GxrGrabState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrGrabState @ {self:p}"))
            .field("grabbed_object", &self.grabbed_object)
            .field("transform_lock", &self.transform_lock)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrHoverState {
    pub hovered_object: gpointer,
    pub distance: c_float,
}

impl ::std::fmt::Debug for GxrHoverState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrHoverState @ {self:p}"))
            .field("hovered_object", &self.hovered_object)
            .field("distance", &self.distance)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrManifestClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GxrManifestClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrManifestClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrModelInterface {
    pub parent: gobject::GTypeInterface,
    pub get_name: Option<unsafe extern "C" fn(*mut GxrModel) -> *mut c_char>,
}

impl ::std::fmt::Debug for GxrModelInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrModelInterface @ {self:p}"))
            .field("parent", &self.parent)
            .field("get_name", &self.get_name)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrOverlayClass {
    pub parent: gobject::GObjectClass,
    pub poll_event: Option<unsafe extern "C" fn(*mut GxrOverlay)>,
    pub set_mouse_scale:
        Option<unsafe extern "C" fn(*mut GxrOverlay, c_float, c_float) -> gboolean>,
    pub is_visible: Option<unsafe extern "C" fn(*mut GxrOverlay) -> gboolean>,
    pub thumbnail_is_visible: Option<unsafe extern "C" fn(*mut GxrOverlay) -> gboolean>,
    pub show: Option<unsafe extern "C" fn(*mut GxrOverlay) -> gboolean>,
    pub hide: Option<unsafe extern "C" fn(*mut GxrOverlay) -> gboolean>,
    pub set_sort_order: Option<unsafe extern "C" fn(*mut GxrOverlay, u32) -> gboolean>,
    pub clear_texture: Option<unsafe extern "C" fn(*mut GxrOverlay) -> gboolean>,
    pub set_alpha: Option<unsafe extern "C" fn(*mut GxrOverlay, *mut c_float) -> gboolean>,
    pub set_width_meters: Option<unsafe extern "C" fn(*mut GxrOverlay, *mut c_float) -> gboolean>,
    pub set_raw: Option<unsafe extern "C" fn(*mut GxrOverlay, *mut u8, u32, u32, u32) -> gboolean>,
    pub get_width_meters: Option<unsafe extern "C" fn(*mut GxrOverlay, *mut c_float) -> gboolean>,
    pub enable_mouse_input: Option<unsafe extern "C" fn(*mut GxrOverlay) -> gboolean>,
    pub show_keyboard: Option<unsafe extern "C" fn(*mut GxrOverlay) -> gboolean>,
    pub print_info: Option<unsafe extern "C" fn(*mut GxrOverlay) -> gboolean>,
    pub set_flip_y: Option<unsafe extern "C" fn(*mut GxrOverlay, gboolean)>,
}

impl ::std::fmt::Debug for GxrOverlayClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrOverlayClass @ {self:p}"))
            .field("parent", &self.parent)
            .field("poll_event", &self.poll_event)
            .field("set_mouse_scale", &self.set_mouse_scale)
            .field("is_visible", &self.is_visible)
            .field("thumbnail_is_visible", &self.thumbnail_is_visible)
            .field("show", &self.show)
            .field("hide", &self.hide)
            .field("set_sort_order", &self.set_sort_order)
            .field("clear_texture", &self.clear_texture)
            .field("set_alpha", &self.set_alpha)
            .field("set_width_meters", &self.set_width_meters)
            .field("set_raw", &self.set_raw)
            .field("get_width_meters", &self.get_width_meters)
            .field("enable_mouse_input", &self.enable_mouse_input)
            .field("show_keyboard", &self.show_keyboard)
            .field("print_info", &self.print_info)
            .field("set_flip_y", &self.set_flip_y)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrPointerData {
    pub start_offset: c_float,
    pub length: c_float,
    pub default_length: c_float,
    pub visible: gboolean,
    pub render_ray: gboolean,
}

impl ::std::fmt::Debug for GxrPointerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrPointerData @ {self:p}"))
            .field("start_offset", &self.start_offset)
            .field("length", &self.length)
            .field("default_length", &self.default_length)
            .field("visible", &self.visible)
            .field("render_ray", &self.render_ray)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrPointerInterface {
    pub parent: gobject::GTypeInterface,
    pub set_length: Option<unsafe extern "C" fn(*mut GxrPointer, c_float)>,
    pub set_selected_object: Option<unsafe extern "C" fn(*mut GxrPointer, gpointer)>,
    pub show: Option<unsafe extern "C" fn(*mut GxrPointer)>,
    pub hide: Option<unsafe extern "C" fn(*mut GxrPointer)>,
}

impl ::std::fmt::Debug for GxrPointerInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrPointerInterface @ {self:p}"))
            .field("parent", &self.parent)
            .field("set_length", &self.set_length)
            .field("set_selected_object", &self.set_selected_object)
            .field("show", &self.show)
            .field("hide", &self.hide)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrPointerTipAnimation {
    pub tip: *mut GxrPointerTip,
    pub progress: c_float,
    pub callback_id: c_uint,
}

impl ::std::fmt::Debug for GxrPointerTipAnimation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrPointerTipAnimation @ {self:p}"))
            .field("tip", &self.tip)
            .field("progress", &self.progress)
            .field("callback_id", &self.callback_id)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrPointerTipData {
    pub tip: *mut GxrPointerTip,
    pub active: gboolean,
    pub settings: GxrPointerTipSettings,
    pub animation: *mut GxrPointerTipAnimation,
}

impl ::std::fmt::Debug for GxrPointerTipData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrPointerTipData @ {self:p}"))
            .field("tip", &self.tip)
            .field("active", &self.active)
            .field("settings", &self.settings)
            .field("animation", &self.animation)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrPointerTipInterface {
    pub parent: gobject::GTypeInterface,
    pub show: Option<unsafe extern "C" fn(*mut GxrPointerTip)>,
    pub hide: Option<unsafe extern "C" fn(*mut GxrPointerTip)>,
    pub is_visible: Option<unsafe extern "C" fn(*mut GxrPointerTip) -> gboolean>,
    pub set_width_meters: Option<unsafe extern "C" fn(*mut GxrPointerTip, c_float)>,
    pub submit_texture: Option<unsafe extern "C" fn(*mut GxrPointerTip)>,
}

impl ::std::fmt::Debug for GxrPointerTipInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrPointerTipInterface @ {self:p}"))
            .field("parent", &self.parent)
            .field("show", &self.show)
            .field("hide", &self.hide)
            .field("is_visible", &self.is_visible)
            .field("set_width_meters", &self.set_width_meters)
            .field("submit_texture", &self.submit_texture)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrPointerTipSettings {
    pub keep_apparent_size: gboolean,
    pub width_meters: c_float,
    pub pulse_alpha: c_double,
    pub texture_width: c_int,
    pub texture_height: c_int,
}

impl ::std::fmt::Debug for GxrPointerTipSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrPointerTipSettings @ {self:p}"))
            .field("keep_apparent_size", &self.keep_apparent_size)
            .field("width_meters", &self.width_meters)
            .field("pulse_alpha", &self.pulse_alpha)
            .field("texture_width", &self.texture_width)
            .field("texture_height", &self.texture_height)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrPose {
    pub is_valid: gboolean,
}

impl ::std::fmt::Debug for GxrPose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrPose @ {self:p}"))
            .field("is_valid", &self.is_valid)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrPoseEvent {
    pub active: gboolean,
    pub valid: gboolean,
    pub device_connected: gboolean,
    pub controller: *mut GxrController,
}

impl ::std::fmt::Debug for GxrPoseEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrPoseEvent @ {self:p}"))
            .field("active", &self.active)
            .field("valid", &self.valid)
            .field("device_connected", &self.device_connected)
            .field("controller", &self.controller)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrQuitEvent {
    pub reason: GxrQuitReason,
}

impl ::std::fmt::Debug for GxrQuitEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrQuitEvent @ {self:p}"))
            .field("reason", &self.reason)
            .finish()
    }
}

// Classes
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrAction {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GxrAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrAction @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrActionSet {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GxrActionSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrActionSet @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
pub struct GxrBackend {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GxrBackend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrBackend @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrContext {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GxrContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrContext @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
pub struct GxrController {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GxrController {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrController @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrDevice {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GxrDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrDevice @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
pub struct GxrDeviceManager {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GxrDeviceManager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrDeviceManager @ {self:p}"))
            .finish()
    }
}

#[repr(C)]
pub struct GxrManifest {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GxrManifest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrManifest @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrOverlay {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GxrOverlay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrOverlay @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

// Interfaces
#[repr(C)]
pub struct GxrModel {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GxrModel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GxrModel @ {self:p}")
    }
}

#[repr(C)]
pub struct GxrPointer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GxrPointer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GxrPointer @ {self:p}")
    }
}

#[repr(C)]
pub struct GxrPointerTip {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GxrPointerTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GxrPointerTip @ {self:p}")
    }
}

#[link(name = "gxr-0.15")]
extern "C" {

    //=========================================================================
    // GxrAction
    //=========================================================================
    pub fn gxr_action_get_type() -> GType;
    pub fn gxr_action_new_from_type_url(
        context: *mut GxrContext,
        action_set: *mut GxrActionSet,
        type_: GxrActionType,
        url: *mut c_char,
    ) -> *mut GxrAction;
    pub fn gxr_action_sets_attach_bindings(
        sets: *mut *mut GxrActionSet,
        context: *mut GxrContext,
        count: u32,
    ) -> gboolean;
    pub fn gxr_action_sets_poll(sets: *mut *mut GxrActionSet, count: u32) -> gboolean;
    pub fn gxr_action_emit_analog(self_: *mut GxrAction, event: *mut GxrAnalogEvent);
    pub fn gxr_action_emit_digital(self_: *mut GxrAction, event: *mut GxrDigitalEvent);
    pub fn gxr_action_emit_pose(self_: *mut GxrAction, event: *mut GxrPoseEvent);
    pub fn gxr_action_get_action_set(self_: *mut GxrAction) -> *mut GxrActionSet;
    pub fn gxr_action_get_action_type(self_: *mut GxrAction) -> GxrActionType;
    pub fn gxr_action_get_url(self_: *mut GxrAction) -> *mut c_char;
    pub fn gxr_action_poll(self_: *mut GxrAction) -> gboolean;
    pub fn gxr_action_set_action_set(self_: *mut GxrAction, action_set: *mut GxrActionSet);
    pub fn gxr_action_set_action_type(self_: *mut GxrAction, type_: GxrActionType);
    pub fn gxr_action_set_digital_from_float_haptic(
        self_: *mut GxrAction,
        haptic_action: *mut GxrAction,
    );
    pub fn gxr_action_set_digital_from_float_threshold(self_: *mut GxrAction, threshold: c_float);
    pub fn gxr_action_set_url(self_: *mut GxrAction, url: *mut c_char);
    pub fn gxr_action_trigger_haptic(
        self_: *mut GxrAction,
        start_seconds_from_now: c_float,
        duration_seconds: c_float,
        frequency: c_float,
        amplitude: c_float,
        controller_handle: u64,
    ) -> gboolean;

    //=========================================================================
    // GxrActionSet
    //=========================================================================
    pub fn gxr_action_set_get_type() -> GType;
    pub fn gxr_action_set_new_from_url(
        context: *mut GxrContext,
        url: *mut c_char,
    ) -> *mut GxrActionSet;
    pub fn gxr_action_set_connect(
        self_: *mut GxrActionSet,
        context: *mut GxrContext,
        type_: GxrActionType,
        url: *mut c_char,
        callback: gobject::GCallback,
        data: gpointer,
    ) -> gboolean;
    pub fn gxr_action_set_connect_digital_from_float(
        self_: *mut GxrActionSet,
        context: *mut GxrContext,
        url: *mut c_char,
        threshold: c_float,
        haptic_url: *mut c_char,
        callback: gobject::GCallback,
        data: gpointer,
    ) -> *mut GxrAction;
    pub fn gxr_action_set_get_actions(self_: *mut GxrActionSet) -> *mut glib::GSList;

    //=========================================================================
    // GxrBackend
    //=========================================================================
    pub fn gxr_backend_get_type() -> GType;
    pub fn gxr_backend_shutdown();

    //=========================================================================
    // GxrContext
    //=========================================================================
    pub fn gxr_context_get_type() -> GType;
    pub fn gxr_context_new(
        type_: GxrAppType,
        app_name: *mut c_char,
        app_version: u32,
    ) -> *mut GxrContext;
    pub fn gxr_context_new_from_api(
        type_: GxrAppType,
        backend: GxrApi,
        app_name: *mut c_char,
        app_version: u32,
    ) -> *mut GxrContext;
    pub fn gxr_context_new_from_vulkan_extensions(
        type_: GxrAppType,
        instance_ext_list: *mut glib::GSList,
        device_ext_list: *mut glib::GSList,
        app_name: *mut c_char,
        app_version: u32,
    ) -> *mut GxrContext;
    pub fn gxr_context_new_full(
        type_: GxrAppType,
        api: GxrApi,
        instance_ext_list: *mut glib::GSList,
        device_ext_list: *mut glib::GSList,
        app_name: *mut c_char,
        app_version: u32,
    ) -> *mut GxrContext;
    pub fn gxr_context_new_headless(app_name: *mut c_char, app_version: u32) -> *mut GxrContext;
    pub fn gxr_context_new_headless_from_api(
        api: GxrApi,
        app_name: *mut c_char,
        app_version: u32,
    ) -> *mut GxrContext;
    pub fn gxr_context_acknowledge_quit(self_: *mut GxrContext);
    pub fn gxr_context_begin_frame(self_: *mut GxrContext) -> gboolean;
    pub fn gxr_context_device_is_controller(self_: *mut GxrContext, i: u32) -> gboolean;
    pub fn gxr_context_end_frame(self_: *mut GxrContext) -> gboolean;
    pub fn gxr_context_get_device_manager(self_: *mut GxrContext) -> *mut GxrDeviceManager;
    pub fn gxr_context_get_device_model_name(self_: *mut GxrContext, i: u32) -> *mut c_char;
    pub fn gxr_context_get_frustum_angles(
        self_: *mut GxrContext,
        eye: GxrEye,
        left: *mut c_float,
        right: *mut c_float,
        top: *mut c_float,
        bottom: *mut c_float,
    );
    pub fn gxr_context_get_model_normal_offset(self_: *mut GxrContext) -> u32;
    pub fn gxr_context_get_model_uv_offset(self_: *mut GxrContext) -> u32;
    pub fn gxr_context_get_model_vertex_stride(self_: *mut GxrContext) -> u32;
    pub fn gxr_context_get_view_count(self_: *mut GxrContext) -> u32;
    pub fn gxr_context_is_another_scene_running(self_: *mut GxrContext) -> gboolean;
    pub fn gxr_context_is_input_available(self_: *mut GxrContext) -> gboolean;
    pub fn gxr_context_is_tracked_device_connected(self_: *mut GxrContext, i: u32) -> gboolean;
    pub fn gxr_context_load_action_manifest(
        self_: *mut GxrContext,
        cache_name: *const c_char,
        resource_path: *const c_char,
        manifest_name: *const c_char,
    ) -> gboolean;
    pub fn gxr_context_poll_event(self_: *mut GxrContext);
    pub fn gxr_context_request_quit(self_: *mut GxrContext);
    pub fn gxr_context_show_keyboard(self_: *mut GxrContext);
    pub fn gxr_context_submit_framebuffers(self_: *mut GxrContext) -> gboolean;

    //=========================================================================
    // GxrController
    //=========================================================================
    pub fn gxr_controller_get_type() -> GType;
    pub fn gxr_controller_new(
        controller_handle: u64,
        context: *mut GxrContext,
        model_name: *mut c_char,
    ) -> *mut GxrController;
    pub fn gxr_controller_get_user_data(self_: *mut GxrController) -> gpointer;
    pub fn gxr_controller_hide_pointer(self_: *mut GxrController);
    pub fn gxr_controller_is_pointer_pose_valid(self_: *mut GxrController) -> gboolean;
    pub fn gxr_controller_is_pointer_visible(self_: *mut GxrController) -> gboolean;
    pub fn gxr_controller_reset_grab_state(self_: *mut GxrController);
    pub fn gxr_controller_reset_hover_state(self_: *mut GxrController);
    pub fn gxr_controller_set_pointer(self_: *mut GxrController, pointer: *mut GxrPointer);
    pub fn gxr_controller_set_pointer_tip(self_: *mut GxrController, tip: *mut GxrPointerTip);
    pub fn gxr_controller_set_user_data(self_: *mut GxrController, data: gpointer);
    pub fn gxr_controller_show_pointer(self_: *mut GxrController);

    //=========================================================================
    // GxrDevice
    //=========================================================================
    pub fn gxr_device_get_type() -> GType;
    pub fn gxr_device_new(device_id: u64, model_name: *mut c_char) -> *mut GxrDevice;
    pub fn gxr_device_get_handle(self_: *mut GxrDevice) -> u64;
    pub fn gxr_device_get_model(self_: *mut GxrDevice) -> *mut GxrModel;
    pub fn gxr_device_get_model_name(self_: *mut GxrDevice) -> *mut c_char;
    pub fn gxr_device_initialize(self_: *mut GxrDevice) -> gboolean;
    pub fn gxr_device_is_controller(self_: *mut GxrDevice) -> gboolean;
    pub fn gxr_device_is_pose_valid(self_: *mut GxrDevice) -> gboolean;
    pub fn gxr_device_set_handle(self_: *mut GxrDevice, handle: u64);
    pub fn gxr_device_set_is_pose_valid(self_: *mut GxrDevice, valid: bool);
    pub fn gxr_device_set_model(self_: *mut GxrDevice, model: *mut GxrModel);
    pub fn gxr_device_set_model_name(self_: *mut GxrDevice, model_name: *mut c_char);

    //=========================================================================
    // GxrDeviceManager
    //=========================================================================
    pub fn gxr_device_manager_get_type() -> GType;
    pub fn gxr_device_manager_new() -> *mut GxrDeviceManager;
    pub fn gxr_device_manager_add(
        self_: *mut GxrDeviceManager,
        context: *mut GxrContext,
        device_id: u64,
        is_controller: bool,
    ) -> gboolean;
    pub fn gxr_device_manager_connect_pose_actions(
        self_: *mut GxrDeviceManager,
        context: *mut GxrContext,
        action_set: *mut GxrActionSet,
        pointer_pose_url: *mut c_char,
        hand_grip_pose_url: *mut c_char,
    );
    pub fn gxr_device_manager_get(self_: *mut GxrDeviceManager, device_id: u64) -> *mut GxrDevice;
    pub fn gxr_device_manager_get_controllers(self_: *mut GxrDeviceManager) -> *mut glib::GSList;
    pub fn gxr_device_manager_get_devices(self_: *mut GxrDeviceManager) -> *mut glib::GList;
    pub fn gxr_device_manager_remove(self_: *mut GxrDeviceManager, device_id: u64);
    pub fn gxr_device_manager_update_poses(self_: *mut GxrDeviceManager, poses: *mut GxrPose);

    //=========================================================================
    // GxrManifest
    //=========================================================================
    pub fn gxr_manifest_get_type() -> GType;
    pub fn gxr_manifest_new() -> *mut GxrManifest;
    pub fn gxr_manifest_get_binding_filenames(self_: *mut GxrManifest) -> *mut glib::GSList;
    pub fn gxr_manifest_get_binding_manifests(manifest: *mut GxrManifest) -> *mut glib::GSList;
    pub fn gxr_manifest_load_actions(
        self_: *mut GxrManifest,
        action_stream: *mut gio::GInputStream,
    ) -> gboolean;
    pub fn gxr_manifest_load_bindings(
        self_: *mut GxrManifest,
        resource_path: *const c_char,
    ) -> gboolean;

    //=========================================================================
    // GxrOverlay
    //=========================================================================
    pub fn gxr_overlay_get_type() -> GType;
    pub fn gxr_overlay_new(context: *mut GxrContext, key: *mut c_char) -> *mut GxrOverlay;
    pub fn gxr_overlay_new_width(
        context: *mut GxrContext,
        key: *mut c_char,
        meters: c_float,
    ) -> *mut GxrOverlay;
    pub fn gxr_overlay_clear_texture(self_: *mut GxrOverlay) -> gboolean;
    pub fn gxr_overlay_enable_mouse_input(self_: *mut GxrOverlay) -> gboolean;
    pub fn gxr_overlay_get_flip_y(self_: *mut GxrOverlay) -> gboolean;
    pub fn gxr_overlay_get_width_meters(self_: *mut GxrOverlay, width: *mut c_float) -> gboolean;
    pub fn gxr_overlay_hide(self_: *mut GxrOverlay) -> gboolean;
    pub fn gxr_overlay_is_visible(self_: *mut GxrOverlay) -> gboolean;
    pub fn gxr_overlay_poll_event(self_: *mut GxrOverlay);
    pub fn gxr_overlay_print_info(self_: *mut GxrOverlay) -> gboolean;
    pub fn gxr_overlay_set_alpha(self_: *mut GxrOverlay, alpha: c_float) -> gboolean;
    pub fn gxr_overlay_set_cairo_surface_raw(
        self_: *mut GxrOverlay,
        surface: *mut cairo::cairo_surface_t,
    ) -> gboolean;
    pub fn gxr_overlay_set_flip_y(self_: *mut GxrOverlay, flip_y: gboolean);
    pub fn gxr_overlay_set_gdk_pixbuf_raw(
        self_: *mut GxrOverlay,
        pixbuf: *mut gdk_pixbuf::GdkPixbuf,
    ) -> gboolean;
    pub fn gxr_overlay_set_mouse_scale(
        self_: *mut GxrOverlay,
        width: c_float,
        height: c_float,
    ) -> gboolean;
    pub fn gxr_overlay_set_raw(
        self_: *mut GxrOverlay,
        pixels: *mut u8,
        width: u32,
        height: u32,
        depth: u32,
    ) -> gboolean;
    pub fn gxr_overlay_set_sort_order(self_: *mut GxrOverlay, sort_order: u32) -> gboolean;
    pub fn gxr_overlay_set_visibility(self_: *mut GxrOverlay, visibility: gboolean) -> gboolean;
    pub fn gxr_overlay_set_width_meters(self_: *mut GxrOverlay, meters: c_float) -> gboolean;
    pub fn gxr_overlay_show(self_: *mut GxrOverlay) -> gboolean;
    pub fn gxr_overlay_show_keyboard(self_: *mut GxrOverlay) -> gboolean;
    pub fn gxr_overlay_thumbnail_is_visible(self_: *mut GxrOverlay) -> gboolean;

    //=========================================================================
    // GxrModel
    //=========================================================================
    pub fn gxr_model_get_type() -> GType;
    pub fn gxr_model_get_name(self_: *mut GxrModel) -> *mut c_char;

    //=========================================================================
    // GxrPointer
    //=========================================================================
    pub fn gxr_pointer_get_type() -> GType;
    pub fn gxr_pointer_get_data(self_: *mut GxrPointer) -> *mut GxrPointerData;
    pub fn gxr_pointer_get_default_length(self_: *mut GxrPointer) -> c_float;
    pub fn gxr_pointer_hide(self_: *mut GxrPointer);
    pub fn gxr_pointer_init(self_: *mut GxrPointer);
    pub fn gxr_pointer_is_visible(self_: *mut GxrPointer) -> gboolean;
    pub fn gxr_pointer_reset_length(self_: *mut GxrPointer);
    pub fn gxr_pointer_set_length(self_: *mut GxrPointer, length: c_float);
    pub fn gxr_pointer_show(self_: *mut GxrPointer);
    pub fn gxr_pointer_update_render_ray(self_: *mut GxrPointer, render_ray: gboolean);

    //=========================================================================
    // GxrPointerTip
    //=========================================================================
    pub fn gxr_pointer_tip_get_type() -> GType;
    pub fn gxr_pointer_tip_animate_pulse(self_: *mut GxrPointerTip);
    pub fn gxr_pointer_tip_get_data(self_: *mut GxrPointerTip) -> *mut GxrPointerTipData;
    pub fn gxr_pointer_tip_hide(self_: *mut GxrPointerTip);
    pub fn gxr_pointer_tip_init_settings(self_: *mut GxrPointerTip, data: *mut GxrPointerTipData);
    pub fn gxr_pointer_tip_is_visible(self_: *mut GxrPointerTip) -> gboolean;
    pub fn gxr_pointer_tip_render(
        self_: *mut GxrPointerTip,
        progress: c_float,
    ) -> *mut gdk_pixbuf::GdkPixbuf;
    pub fn gxr_pointer_tip_set_active(self_: *mut GxrPointerTip, active: gboolean);
    pub fn gxr_pointer_tip_set_width_meters(self_: *mut GxrPointerTip, meters: c_float);
    pub fn gxr_pointer_tip_show(self_: *mut GxrPointerTip);
    pub fn gxr_pointer_tip_submit_texture(self_: *mut GxrPointerTip);
    pub fn gxr_pointer_tip_update_apparent_size(
        self_: *mut GxrPointerTip,
        context: *mut GxrContext,
    );
    pub fn gxr_pointer_tip_update_keep_apparent_size(
        self_: *mut GxrPointerTip,
        keep_apparent_size: gboolean,
    );
    pub fn gxr_pointer_tip_update_pulse_alpha(self_: *mut GxrPointerTip, alpha: c_double);
    pub fn gxr_pointer_tip_update_texture_resolution(
        self_: *mut GxrPointerTip,
        width: c_int,
        height: c_int,
    );
    pub fn gxr_pointer_tip_update_width_meters(self_: *mut GxrPointerTip, width: c_float);

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn gxr_io_create_directory_if_needed(path: *mut c_char) -> gboolean;
    pub fn gxr_io_get_cache_path(dir_name: *const c_char) -> *mut glib::GString;
    pub fn gxr_io_write_resource_to_file(
        res_base_path: *const c_char,
        cache_path: *mut c_char,
        file_name: *const c_char,
        file_path: *mut glib::GString,
    ) -> gboolean;
    pub fn gxr_time_age_secs_to_monotonic_msecs(age: c_float) -> u32;

}
