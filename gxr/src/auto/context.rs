// Generated by gir (https://github.com/gtk-rs/gir @ 2358cc24efd2)
// from ../gir-files (@ eab91ba8f88b)
// from ../xrd-gir-files (@ 3896faadf111)
// DO NOT EDIT

use glib::{
    prelude::*,
    signal::{connect_raw, SignalHandlerId},
    translate::*,
};
use std::{boxed::Box as Box_, fmt, mem::transmute};

glib::wrapper! {
    #[doc(alias = "GxrContext")]
    pub struct Context(Object<ffi::GxrContext, ffi::GxrContextClass>);

    match fn {
        type_ => || ffi::gxr_context_get_type(),
    }
}

impl Context {
    pub const NONE: Option<&'static Context> = None;

    //#[doc(alias = "gxr_context_new")]
    //pub fn new(type_: /*Ignored*/AppType, app_name: &str, app_version: u32) -> Context {
    //    unsafe { TODO: call ffi:gxr_context_new() }
    //}

    //#[doc(alias = "gxr_context_new_from_api")]
    //#[doc(alias = "new_from_api")]
    //pub fn from_api(type_: /*Ignored*/AppType, backend: /*Ignored*/Api, app_name: &str, app_version: u32) -> Context {
    //    unsafe { TODO: call ffi:gxr_context_new_from_api() }
    //}

    //#[doc(alias = "gxr_context_new_from_vulkan_extensions")]
    //#[doc(alias = "new_from_vulkan_extensions")]
    //pub fn from_vulkan_extensions(type_: /*Ignored*/AppType, instance_ext_list: /*Unimplemented*/&[&Basic: Pointer], device_ext_list: /*Unimplemented*/&[&Basic: Pointer], app_name: &str, app_version: u32) -> Context {
    //    unsafe { TODO: call ffi:gxr_context_new_from_vulkan_extensions() }
    //}

    //#[doc(alias = "gxr_context_new_full")]
    //pub fn new_full(type_: /*Ignored*/AppType, api: /*Ignored*/Api, instance_ext_list: /*Unimplemented*/&[&Basic: Pointer], device_ext_list: /*Unimplemented*/&[&Basic: Pointer], app_name: &str, app_version: u32) -> Context {
    //    unsafe { TODO: call ffi:gxr_context_new_full() }
    //}

    #[doc(alias = "gxr_context_new_headless")]
    pub fn new_headless(app_name: &str, app_version: u32) -> Context {
        unsafe {
            from_glib_full(ffi::gxr_context_new_headless(
                app_name.to_glib_none().0,
                app_version,
            ))
        }
    }

    //#[doc(alias = "gxr_context_new_headless_from_api")]
    //pub fn new_headless_from_api(api: /*Ignored*/Api, app_name: &str, app_version: u32) -> Context {
    //    unsafe { TODO: call ffi:gxr_context_new_headless_from_api() }
    //}
}

unsafe impl Send for Context {}
unsafe impl Sync for Context {}

/// Trait containing all [`struct@Context`] methods.
///
/// # Implementors
///
/// [`Context`][struct@crate::Context]
pub trait ContextExt: 'static {
    #[doc(alias = "gxr_context_acknowledge_quit")]
    fn acknowledge_quit(&self);

    #[doc(alias = "gxr_context_begin_frame")]
    fn begin_frame(&self) -> bool;

    #[doc(alias = "gxr_context_device_is_controller")]
    fn device_is_controller(&self, i: u32) -> bool;

    #[doc(alias = "gxr_context_end_frame")]
    fn end_frame(&self) -> bool;

    //#[doc(alias = "gxr_context_get_device_manager")]
    //#[doc(alias = "get_device_manager")]
    //fn device_manager(&self) -> /*Unimplemented*/Option<Basic: Pointer>;

    #[doc(alias = "gxr_context_get_device_model_name")]
    #[doc(alias = "get_device_model_name")]
    fn device_model_name(&self, i: u32) -> Option<glib::GString>;

    //#[doc(alias = "gxr_context_get_frustum_angles")]
    //#[doc(alias = "get_frustum_angles")]
    //fn frustum_angles(&self, eye: /*Ignored*/Eye, left: f32, right: f32, top: f32, bottom: f32);

    #[doc(alias = "gxr_context_get_model_normal_offset")]
    #[doc(alias = "get_model_normal_offset")]
    fn model_normal_offset(&self) -> u32;

    #[doc(alias = "gxr_context_get_model_uv_offset")]
    #[doc(alias = "get_model_uv_offset")]
    fn model_uv_offset(&self) -> u32;

    #[doc(alias = "gxr_context_get_model_vertex_stride")]
    #[doc(alias = "get_model_vertex_stride")]
    fn model_vertex_stride(&self) -> u32;

    #[doc(alias = "gxr_context_get_view_count")]
    #[doc(alias = "get_view_count")]
    fn view_count(&self) -> u32;

    #[doc(alias = "gxr_context_is_another_scene_running")]
    fn is_another_scene_running(&self) -> bool;

    #[doc(alias = "gxr_context_is_input_available")]
    fn is_input_available(&self) -> bool;

    #[doc(alias = "gxr_context_is_tracked_device_connected")]
    fn is_tracked_device_connected(&self, i: u32) -> bool;

    #[doc(alias = "gxr_context_load_action_manifest")]
    fn load_action_manifest(
        &self,
        cache_name: &str,
        resource_path: &str,
        manifest_name: &str,
    ) -> bool;

    #[doc(alias = "gxr_context_poll_event")]
    fn poll_event(&self);

    #[doc(alias = "gxr_context_request_quit")]
    fn request_quit(&self);

    #[doc(alias = "gxr_context_show_keyboard")]
    fn show_keyboard(&self);

    #[doc(alias = "gxr_context_submit_framebuffers")]
    fn submit_framebuffers(&self) -> bool;

    #[doc(alias = "action-set-update-event")]
    fn connect_action_set_update_event<F: Fn(&Self) + Send + Sync + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[doc(alias = "binding-loaded-event")]
    fn connect_binding_loaded_event<F: Fn(&Self) + Send + Sync + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[doc(alias = "bindings-update-event")]
    fn connect_bindings_update_event<F: Fn(&Self) + Send + Sync + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    //#[doc(alias = "device-update-event")]
    //fn connect_device_update_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "keyboard-close-event")]
    fn connect_keyboard_close_event<F: Fn(&Self) + Send + Sync + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    //#[doc(alias = "keyboard-press-event")]
    //fn connect_keyboard_press_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    //#[doc(alias = "quit-event")]
    //fn connect_quit_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Context>> ContextExt for O {
    fn acknowledge_quit(&self) {
        unsafe {
            ffi::gxr_context_acknowledge_quit(self.as_ref().to_glib_none().0);
        }
    }

    fn begin_frame(&self) -> bool {
        unsafe { from_glib(ffi::gxr_context_begin_frame(self.as_ref().to_glib_none().0)) }
    }

    fn device_is_controller(&self, i: u32) -> bool {
        unsafe {
            from_glib(ffi::gxr_context_device_is_controller(
                self.as_ref().to_glib_none().0,
                i,
            ))
        }
    }

    fn end_frame(&self) -> bool {
        unsafe { from_glib(ffi::gxr_context_end_frame(self.as_ref().to_glib_none().0)) }
    }

    //fn device_manager(&self) -> /*Unimplemented*/Option<Basic: Pointer> {
    //    unsafe { TODO: call ffi:gxr_context_get_device_manager() }
    //}

    fn device_model_name(&self, i: u32) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::gxr_context_get_device_model_name(
                self.as_ref().to_glib_none().0,
                i,
            ))
        }
    }

    //fn frustum_angles(&self, eye: /*Ignored*/Eye, left: f32, right: f32, top: f32, bottom: f32) {
    //    unsafe { TODO: call ffi:gxr_context_get_frustum_angles() }
    //}

    fn model_normal_offset(&self) -> u32 {
        unsafe { ffi::gxr_context_get_model_normal_offset(self.as_ref().to_glib_none().0) }
    }

    fn model_uv_offset(&self) -> u32 {
        unsafe { ffi::gxr_context_get_model_uv_offset(self.as_ref().to_glib_none().0) }
    }

    fn model_vertex_stride(&self) -> u32 {
        unsafe { ffi::gxr_context_get_model_vertex_stride(self.as_ref().to_glib_none().0) }
    }

    fn view_count(&self) -> u32 {
        unsafe { ffi::gxr_context_get_view_count(self.as_ref().to_glib_none().0) }
    }

    fn is_another_scene_running(&self) -> bool {
        unsafe {
            from_glib(ffi::gxr_context_is_another_scene_running(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn is_input_available(&self) -> bool {
        unsafe {
            from_glib(ffi::gxr_context_is_input_available(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn is_tracked_device_connected(&self, i: u32) -> bool {
        unsafe {
            from_glib(ffi::gxr_context_is_tracked_device_connected(
                self.as_ref().to_glib_none().0,
                i,
            ))
        }
    }

    fn load_action_manifest(
        &self,
        cache_name: &str,
        resource_path: &str,
        manifest_name: &str,
    ) -> bool {
        unsafe {
            from_glib(ffi::gxr_context_load_action_manifest(
                self.as_ref().to_glib_none().0,
                cache_name.to_glib_none().0,
                resource_path.to_glib_none().0,
                manifest_name.to_glib_none().0,
            ))
        }
    }

    fn poll_event(&self) {
        unsafe {
            ffi::gxr_context_poll_event(self.as_ref().to_glib_none().0);
        }
    }

    fn request_quit(&self) {
        unsafe {
            ffi::gxr_context_request_quit(self.as_ref().to_glib_none().0);
        }
    }

    fn show_keyboard(&self) {
        unsafe {
            ffi::gxr_context_show_keyboard(self.as_ref().to_glib_none().0);
        }
    }

    fn submit_framebuffers(&self) -> bool {
        unsafe {
            from_glib(ffi::gxr_context_submit_framebuffers(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn connect_action_set_update_event<F: Fn(&Self) + Send + Sync + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn action_set_update_event_trampoline<
            P: IsA<Context>,
            F: Fn(&P) + Send + Sync + 'static,
        >(
            this: *mut ffi::GxrContext,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Context::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"action-set-update-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    action_set_update_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_binding_loaded_event<F: Fn(&Self) + Send + Sync + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn binding_loaded_event_trampoline<
            P: IsA<Context>,
            F: Fn(&P) + Send + Sync + 'static,
        >(
            this: *mut ffi::GxrContext,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Context::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"binding-loaded-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    binding_loaded_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_bindings_update_event<F: Fn(&Self) + Send + Sync + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn bindings_update_event_trampoline<
            P: IsA<Context>,
            F: Fn(&P) + Send + Sync + 'static,
        >(
            this: *mut ffi::GxrContext,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Context::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"bindings-update-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    bindings_update_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    //fn connect_device_update_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Unimplemented object: *.Pointer
    //}

    fn connect_keyboard_close_event<F: Fn(&Self) + Send + Sync + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn keyboard_close_event_trampoline<
            P: IsA<Context>,
            F: Fn(&P) + Send + Sync + 'static,
        >(
            this: *mut ffi::GxrContext,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Context::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"keyboard-close-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    keyboard_close_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    //fn connect_keyboard_press_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Unimplemented object: *.Pointer
    //}

    //fn connect_quit_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Unimplemented object: *.Pointer
    //}
}

impl fmt::Display for Context {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Context")
    }
}
